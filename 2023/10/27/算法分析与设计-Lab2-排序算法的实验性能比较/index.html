<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>算法分析与设计 - Lab2 - 排序算法的性能比较 - Zylll&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Zylll&#039;s blog"><meta name="msapplication-TileImage" content="https://s1.imagehub.cc/images/2024/11/14/f79cc6ed028bbcff3a58bd3de64b0be6.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Zylll&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="实现插入排序（Insertion Sort，IS），自顶向下归并排序（Top-down Mergesort，TDM），自底向上归并排序（Bottom-up Mergesort，BUM），随机快速排序（Random Quicksort，RQ），Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）。"><meta property="og:type" content="blog"><meta property="og:title" content="算法分析与设计 - Lab2 - 排序算法的性能比较"><meta property="og:url" content="http://example.com/2023/10/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab2-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"><meta property="og:site_name" content="Zylll&#039;s blog"><meta property="og:description" content="实现插入排序（Insertion Sort，IS），自顶向下归并排序（Top-down Mergesort，TDM），自底向上归并排序（Bottom-up Mergesort，BUM），随机快速排序（Random Quicksort，RQ），Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/20db3d30be58146658c09c1962380cf9.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/3c831a00b72ff229fa2cecc9859cfa0f.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/a48afde36ec35ac5574632181f273368.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/6b5f8064b9c857dca7a5523feb426771.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/da536b2e2cbd1e80dcb0a0644b42312a.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/297749772dce5a9d48d6db88c1c2551b.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/ea73251725d77acadd2192351896ce25.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/3b05d1b1fd43dba843d7bc7957d2f3ec.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/04e3d4449a303fd3e9230bc9ab38e334.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/b6cd7c15857a275c28a789968e887a88.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/390a7c71375997f3673f1d7496dcb2fd.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/6b5f8064b9c857dca7a5523feb426771.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/3451d992cd1caa0f24e64ae6ac727bea.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/a9d05c65db3968027f730cf3df26a5ce.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/95b498a0cfc7a5682d9d3fb4b70335cf.png"><meta property="og:image" content="https://s1.imagehub.cc/images/2023/10/27/b6cd7c15857a275c28a789968e887a88.png"><meta property="article:published_time" content="2023-10-27T08:40:06.000Z"><meta property="article:modified_time" content="2023-10-27T09:09:30.830Z"><meta property="article:author" content="Zylll"><meta property="article:tag" content="算法实验"><meta property="article:tag" content="排序"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://s1.imagehub.cc/images/2023/10/27/20db3d30be58146658c09c1962380cf9.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2023/10/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab2-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},"headline":"算法分析与设计 - Lab2 - 排序算法的性能比较","image":["https://s1.imagehub.cc/images/2023/10/27/20db3d30be58146658c09c1962380cf9.png","https://s1.imagehub.cc/images/2023/10/27/3c831a00b72ff229fa2cecc9859cfa0f.png","https://s1.imagehub.cc/images/2023/10/27/a48afde36ec35ac5574632181f273368.png","https://s1.imagehub.cc/images/2023/10/27/6b5f8064b9c857dca7a5523feb426771.png","https://s1.imagehub.cc/images/2023/10/27/da536b2e2cbd1e80dcb0a0644b42312a.png","https://s1.imagehub.cc/images/2023/10/27/297749772dce5a9d48d6db88c1c2551b.png","https://s1.imagehub.cc/images/2023/10/27/ea73251725d77acadd2192351896ce25.png","https://s1.imagehub.cc/images/2023/10/27/3b05d1b1fd43dba843d7bc7957d2f3ec.png","https://s1.imagehub.cc/images/2023/10/27/04e3d4449a303fd3e9230bc9ab38e334.png","https://s1.imagehub.cc/images/2023/10/27/b6cd7c15857a275c28a789968e887a88.png","https://s1.imagehub.cc/images/2023/10/27/390a7c71375997f3673f1d7496dcb2fd.png","https://s1.imagehub.cc/images/2023/10/27/6b5f8064b9c857dca7a5523feb426771.png","https://s1.imagehub.cc/images/2023/10/27/3451d992cd1caa0f24e64ae6ac727bea.png","https://s1.imagehub.cc/images/2023/10/27/a9d05c65db3968027f730cf3df26a5ce.png","https://s1.imagehub.cc/images/2023/10/27/95b498a0cfc7a5682d9d3fb4b70335cf.png","https://s1.imagehub.cc/images/2023/10/27/b6cd7c15857a275c28a789968e887a88.png"],"datePublished":"2023-10-27T08:40:06.000Z","dateModified":"2023-10-27T09:09:30.830Z","author":{"@type":"Person","name":"Zylll"},"publisher":{"@type":"Organization","name":"Zylll's blog","logo":{"@type":"ImageObject","url":{"text":"Zylll's Blog"}}},"description":"实现插入排序（Insertion Sort，IS），自顶向下归并排序（Top-down Mergesort，TDM），自底向上归并排序（Bottom-up Mergesort，BUM），随机快速排序（Random Quicksort，RQ），Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）。"}</script><link rel="canonical" href="http://example.com/2023/10/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab2-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"><link rel="icon" href="https://s1.imagehub.cc/images/2024/11/14/f79cc6ed028bbcff3a58bd3de64b0be6.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Zylll&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" target="_blank" rel="noopener" href="https://sakamotocoda.com/2024/11/13/About%20me/">About me</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-27T08:40:06.000Z" title="2023/10/27 16:40:06">2023-10-27</time>发表</span><span class="level-item"><time dateTime="2023-10-27T09:09:30.830Z" title="2023/10/27 17:09:30">2023-10-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/">专业知识</a></span><span class="level-item">19 分钟读完 (大约2809个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">算法分析与设计 - Lab2 - 排序算法的性能比较</h1><div class="content"><h4 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一. 实验目的"></a>一. 实验目的</h4><p>实现插入排序（Insertion Sort，IS），自顶向下归并排序（Top-down Mergesort，TDM），自底向上归并排序（Bottom-up Mergesort，BUM），随机快速排序（Random Quicksort，RQ），Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）。</p>
<h4 id="二-实验内容"><a href="#二-实验内容" class="headerlink" title="二. 实验内容"></a>二. 实验内容</h4><p>在计算机上针对不同输入规模数据进行实验，对比上述排序算法的时间及空间占用性能。要求对于每次输入运行 10 次，记录每次时间&#x2F;空间占用，取平均值。</p>
<h4 id="三-实验过程"><a href="#三-实验过程" class="headerlink" title="三. 实验过程"></a>三. 实验过程</h4><p>首先需要明白实验中所需排序算法的基本原理。笔者在相同的实验环境下分别实现了这几种排序，尽量保证了实验结果不受环境所影响。</p>
<h5 id="1-插入排序（Insertion-Sort，IS）"><a href="#1-插入排序（Insertion-Sort，IS）" class="headerlink" title="1. 插入排序（Insertion Sort，IS）"></a>1. 插入排序（Insertion Sort，IS）</h5><p>该排序每次将一个元素放到序列中的正确位置，做法是与它前面的元素依次比较，直到找到正确的位置。</p>
<p>正确性证明显而易见：由于是从左往右依次处理每个位置的元素的，所以待排元素左边的子序列一定是单调的。</p>
<p>算法的时间复杂度为 $O(n ^ 2)$，但由于其排序利用的性质，插入排序在大量递增的数据面前能有较好的表现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = a[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; x) &#123;</span><br><span class="line">            a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-自顶向下归并排序（Top-down-Mergesort，TDM）"><a href="#2-自顶向下归并排序（Top-down-Mergesort，TDM）" class="headerlink" title="2. 自顶向下归并排序（Top-down Mergesort，TDM）"></a>2. 自顶向下归并排序（Top-down Mergesort，TDM）</h5><p>由于大的序列排序问题可以分解为其子序列的排序子问题（<strong>分治法</strong>），故可以将目前的 $[l, r]$ 区间划分为 $[l, mid]$ 和 $[mid + 1, r]$，<strong>递归</strong>处理。递归回溯过后的这两段区间一定是有序的，进而可以合并这两个子区间，来得到排序过后的 $[l, r]$。</p>
<p>合并的方法即每次取这两个子序列中较小的那个数字，依次放到新的序列里。最后还需要把未放完的子序列中的数字集体放入新序列中。这样得到的新序列一定是有序的。</p>
<p>算法的时间复杂度为 $O(n \log n)$，是一种比较稳定且优秀的排序方法，并且还有一些应用（e.g. 计算某个序列中的逆序对个数）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TDM</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">TDM</span>(l, mid);</span><br><span class="line">	<span class="built_in">TDM</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = l;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i] &gt; a[j]) b[k++] = a[j++];</span><br><span class="line">		<span class="keyword">else</span> b[k++] = a[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) b[k++] = a[i++];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r) b[k++] = a[j++];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt;= r; k++) a[k] = b[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-自底向上归并排序（Bottom-up-Mergesort，BUM）"><a href="#3-自底向上归并排序（Bottom-up-Mergesort，BUM）" class="headerlink" title="3. 自底向上归并排序（Bottom-up Mergesort，BUM）"></a>3. 自底向上归并排序（Bottom-up Mergesort，BUM）</h5><p>与 TDM 不同，我们也可以把小的有序序列们依次合并成大的有序序列，这样也可以实现整体的排序。元素的个数可以采用 $2$ 的整数次幂，这样的子序列的长度也比较平均。</p>
<p>算法的时间复杂度为 $O(n \log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - l + <span class="number">1</span>, n2 = r - mid;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n1 + <span class="number">5</span>)</span>, <span class="title">c</span><span class="params">(n2 + <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) b[i] = a[l + i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n2; i++) c[i] = a[mid + i];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, k = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n1 &amp;&amp; j &lt;= n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &lt;= c[j]) a[k++] = b[i++];</span><br><span class="line">        <span class="keyword">else</span> a[k++] = c[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n1) a[k++] = b[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n2) a[k++] = c[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BUM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> now = <span class="number">1</span>; now &lt;= n; now &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l += <span class="number">2</span> * now) &#123;</span><br><span class="line">            <span class="type">int</span> mid = <span class="built_in">min</span>(l + now - <span class="number">1</span>, n), r = <span class="built_in">min</span>(l + <span class="number">2</span> * now - <span class="number">1</span>, n);</span><br><span class="line">            <span class="built_in">merge</span>(l, mid, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-随机快速排序（Random-Quicksort，RQ）"><a href="#4-随机快速排序（Random-Quicksort，RQ）" class="headerlink" title="4. 随机快速排序（Random Quicksort，RQ）"></a>4. 随机快速排序（Random Quicksort，RQ）</h5><p>快速排序与归并排序（Merge Sort）一样，采用了分治的思想，在每次处理区间的时候，选取一个基准值 $pivot &#x3D; a[x]$，让 $pivot$ 左边所有数字都小于它本身，让 $pivot$ 右边所有数字都大于它本身。然后再去递归基准值左右两边的区间。</p>
<p>不难发现排序的快慢会受到 $pivot$ 选取策略的影响。随机的去选择 $pivot$ 可以让排序的效率不被输入数据的顺序、大小的特点而明显影响到。</p>
<p>算法的时间复杂度为 $O(n \log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RQ</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> i = l, j = r, pivot = a[l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>)];</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">		<span class="keyword">while</span>(a[i] &lt; pivot) i++;</span><br><span class="line">		<span class="keyword">while</span>(a[j] &gt; pivot) j--;</span><br><span class="line">		<span class="keyword">if</span>(i &lt;= j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">			i++;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">RQ</span>(l, j);</span><br><span class="line">	<span class="built_in">RQ</span>(i, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-Dijkstra-3-路划分快速排序（Quicksort-with-Dijkstra-3-way-Partition，QD3P）"><a href="#5-Dijkstra-3-路划分快速排序（Quicksort-with-Dijkstra-3-way-Partition，QD3P）" class="headerlink" title="5. Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）"></a>5. Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）</h5><p>QD3P 也使用了基准数 $pivot$ 的概念，将数组分成三个部分：小于 $pivot$ 的部分、等于 $pivot$ 的部分和大于 $pivot$ 的部分。然后递归地对这三个部分分别进行排序，以完成整个排序过程。在处理包含大量重复元素的数据时会展现出优秀的性能。</p>
<p>算法的时间复杂度为 $O(n \log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QD3P</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> lt = l, gt = r, i = l + <span class="number">1</span>, pivot = a[l];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[lt], a[i]);</span><br><span class="line">            lt++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[gt]);</span><br><span class="line">            gt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">QD3P</span>(l, lt - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QD3P</span>(gt + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测量时间与空间占用量"><a href="#测量时间与空间占用量" class="headerlink" title="测量时间与空间占用量"></a>测量时间与空间占用量</h5><p>笔者在此次实验中采用了<strong>线上评测系统</strong>来更方便的去测试不同排序程序在不同规模数据下的性能表现。即先在本地通过数据生成器，将不同规模、不同特点的数据打包上传至评测系统的服务器，再将各个排序的程序分别提交，查看运行时候的时间、空间占用量。</p>
<p>本次线上评测系统选择的是<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/">洛谷平台</a>，洛谷平台为用户提供了「创建题目」以及「提交测评」的功能。</p>
<p>评测结果界面：</p>
<p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1w3rqq"><img src="https://s1.imagehub.cc/images/2023/10/27/20db3d30be58146658c09c1962380cf9.png" alt="20db3d30be58146658c09c1962380cf9.png"></a></p>
<p>以下是用于此次评测的题目的相关信息：</p>
<p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1w3dWL"><img src="https://s1.imagehub.cc/images/2023/10/27/3c831a00b72ff229fa2cecc9859cfa0f.png" alt="3c831a00b72ff229fa2cecc9859cfa0f.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1w3b3U"><img src="https://s1.imagehub.cc/images/2023/10/27/a48afde36ec35ac5574632181f273368.png" alt="a48afde36ec35ac5574632181f273368.png"></a></p>
<p>本地的数据生成器（generator.cpp）代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">20050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; <span class="built_in">rand</span>() % <span class="number">50</span> &lt;&lt; (i == n ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// generate random data</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        a[++m] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cout &lt;&lt; a[i] &lt;&lt; (i == m ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//generate data which has been sorted</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>)); <span class="comment">// for random data</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;sort.in&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout); <span class="comment">// write the generated data in the file</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">20000</span>, type; <span class="comment">// set the number of data</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; type;</span><br><span class="line">    type ? <span class="built_in">solve1</span>() : <span class="built_in">solve2</span>(); <span class="comment">// choose different kinds of data</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地的排序过后（sort.cpp）的数据生成器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, a[<span class="number">20050</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;sort0.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;sort0.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout); <span class="comment">// generate the right answer after sorting</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span> (a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; (i == n ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运用线上评测的优势是方便查看时间、空间的占用量，并且能够检测程序的正确性。缺点是显示精度取决于评测提供方，结果可能不够精确。</p>
<h4 id="四-结果分析"><a href="#四-结果分析" class="headerlink" title="四. 结果分析"></a>四. 结果分析</h4><h5 id="1-大量有序数据（N-20000）"><a href="#1-大量有序数据（N-20000）" class="headerlink" title="1. 大量有序数据（N &#x3D; 20000）"></a>1. 大量有序数据（N &#x3D; 20000）</h5><p>时间占用（单位：$\mu s$）：</p>
<p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1wOgYv"><img src="https://s1.imagehub.cc/images/2023/10/27/6b5f8064b9c857dca7a5523feb426771.png" alt="6b5f8064b9c857dca7a5523feb426771.png"></a></p>
<p>空间占用（单位：$kb$）：</p>
<p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1wOeOt"><img src="https://s1.imagehub.cc/images/2023/10/27/da536b2e2cbd1e80dcb0a0644b42312a.png" alt="da536b2e2cbd1e80dcb0a0644b42312a.png"></a></p>
<h5 id="2-大量重复数据（N-20000）"><a href="#2-大量重复数据（N-20000）" class="headerlink" title="2. 大量重复数据（N &#x3D; 20000）"></a>2. 大量重复数据（N &#x3D; 20000）</h5><p>时间占用（单位：$\mu s$）：</p>
<p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1wOlkS"><img src="https://s1.imagehub.cc/images/2023/10/27/297749772dce5a9d48d6db88c1c2551b.png" alt="297749772dce5a9d48d6db88c1c2551b.png"></a></p>
<p>空间占用（单位：$kb$）：</p>
<p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1wO0FL"><img src="https://s1.imagehub.cc/images/2023/10/27/ea73251725d77acadd2192351896ce25.png" alt="ea73251725d77acadd2192351896ce25.png"></a></p>
<h5 id="3-大量随机数据（N-20000）"><a href="#3-大量随机数据（N-20000）" class="headerlink" title="3. 大量随机数据（N &#x3D; 20000）"></a>3. 大量随机数据（N &#x3D; 20000）</h5><p>时间占用（单位：$\mu s$）：</p>
<p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1wx7JJ"><img src="https://s1.imagehub.cc/images/2023/10/27/3b05d1b1fd43dba843d7bc7957d2f3ec.png" alt="3b05d1b1fd43dba843d7bc7957d2f3ec.png"></a></p>
<p>空间占用（单位：$kb$）：</p>
<p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1wOnjq"><img src="https://s1.imagehub.cc/images/2023/10/27/04e3d4449a303fd3e9230bc9ab38e334.png" alt="04e3d4449a303fd3e9230bc9ab38e334.png"></a></p>
<h5 id="4-少量随机数据（N-1000）"><a href="#4-少量随机数据（N-1000）" class="headerlink" title="4. 少量随机数据（N &#x3D; 1000）"></a>4. 少量随机数据（N &#x3D; 1000）</h5><p>时间占用（单位：$\mu s$）：</p>
<p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1wOBXU"><img src="https://s1.imagehub.cc/images/2023/10/27/b6cd7c15857a275c28a789968e887a88.png" alt="b6cd7c15857a275c28a789968e887a88.png"></a></p>
<p>空间占用（单位：$kb$）：</p>
<p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1wOOI0"><img src="https://s1.imagehub.cc/images/2023/10/27/390a7c71375997f3673f1d7496dcb2fd.png" alt="390a7c71375997f3673f1d7496dcb2fd.png"></a></p>
<h4 id="五-问题回答"><a href="#五-问题回答" class="headerlink" title="五. 问题回答"></a>五. 问题回答</h4><ol>
<li><p>Which sort worked best on data in constant or increasing order (i.e., <strong>already sorted data</strong>)? Why do you think this sort worked best?<br> (1). Insertion Sort. In the first test, Insertion Sort solves the problem the fastest.<br> <a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1wOgYv"><img src="https://s1.imagehub.cc/images/2023/10/27/6b5f8064b9c857dca7a5523feb426771.png" alt="6b5f8064b9c857dca7a5523feb426771.png"></a><br> (2). This is because when the sequence is already sorted, everytime we want to arrange this element to its right position, we can <strong>add it to the final sequence directly</strong>. Its time complexity turns to $O(n)$.</p>
</li>
<li><p>Did the same sort do well on the case of mostly sorted data? Why or why not?<br> (1). For Insertion Sort, it runs <strong>much more faster</strong> than it runs on the random situation. The reason why has been explained in last question.<br> <a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1wtgUS"><img src="https://s1.imagehub.cc/images/2023/10/27/3451d992cd1caa0f24e64ae6ac727bea.png" alt="3451d992cd1caa0f24e64ae6ac727bea.png"></a><br> (2). For QD3P, it runs <strong>much more slower</strong> than it runs on the mostly repeated situation.<br> <a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1wtleB"><img src="https://s1.imagehub.cc/images/2023/10/27/a9d05c65db3968027f730cf3df26a5ce.png" alt="a9d05c65db3968027f730cf3df26a5ce.png"></a></p>
</li>
<li><p>In general, did the ordering of the incoming data affect the performance of the sorting algorithms? Please answer this question by referencing specific data from your table to support your answer.<br> (1). Yes.<br> (2). For QD3P, when the data is generated randomly, the cost of time is <strong>much more shorter</strong> than it runs on sorted data.<br> <a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1w43tz"><img src="https://s1.imagehub.cc/images/2023/10/27/95b498a0cfc7a5682d9d3fb4b70335cf.png" alt="95b498a0cfc7a5682d9d3fb4b70335cf.png"></a></p>
</li>
<li><p>Which sort did best on the shorter (i.e., n &#x3D; 1,000) data sets? Did the same one do better on the longer (i.e., n &#x3D; 100,000) data sets? Why or why not? Please use specific data from your table to support your answer.<br> (1). When $n$ is not very large (e.g. n &#x3D; 1000), different algorithms takes almost same time to sort.<br> <a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/1wOBXU"><img src="https://s1.imagehub.cc/images/2023/10/27/b6cd7c15857a275c28a789968e887a88.png" alt="b6cd7c15857a275c28a789968e887a88.png"></a><br> (2). When $n$ is very large, which algorithm works best depends on whether the data is already sorted and the number of repeated number in the data set. Theoretically speaking, QD3P works best in most condition, especially when there are many repeated elements in the data set. But there are also some speical cases.</p>
</li>
<li><p>In general, which sort did better? Give a hypothesis as to why the difference in performance exists.<br> (1). QD3P works best in most condition.<br> (2). The performance depends on many aspects, including the size of data, whether the sequence is already sorted, and whether it will use the space of system stack and so on.</p>
</li>
<li><p>Are there results in your table that seem to be inconsistent? (e.g., If I get run times for a sort that look like this <code>&#123;1.3, 1.5, 1.6, 7.0, 1.2, 1.6, 1.4, 1.8, 2.0, 1.5&#125;</code> the <code>7.0</code> entry is not consistent with the rest). Why do you think this happened?<br> (1). I think it is related to the data and system environment.</p>
</li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>算法分析与设计 - Lab2 - 排序算法的性能比较</p><p><a href="http://example.com/2023/10/27/算法分析与设计-Lab2-排序算法的实验性能比较/">http://example.com/2023/10/27/算法分析与设计-Lab2-排序算法的实验性能比较/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Zylll</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-10-27</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-10-27</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/">算法实验</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">计算机组织与体系结构课程设计 - 实验报告</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/10/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab1-%E6%B8%97%E9%80%8F%E9%97%AE%E9%A2%98/"><span class="level-item">算法分析与设计 - Lab1 - 渗透问题</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://s1.imagehub.cc/images/2024/11/12/bf93f90311c802220474e9bf8ff8b3d4.jpg" alt="Zylll"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Zylll</p><p class="is-size-6 is-block">sakamotocoda@gmail.com</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xi&#039;an Jiaotong University</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">14</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一-实验目的"><span class="level-left"><span class="level-item">1</span><span class="level-item">一. 实验目的</span></span></a></li><li><a class="level is-mobile" href="#二-实验内容"><span class="level-left"><span class="level-item">2</span><span class="level-item">二. 实验内容</span></span></a></li><li><a class="level is-mobile" href="#三-实验过程"><span class="level-left"><span class="level-item">3</span><span class="level-item">三. 实验过程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-插入排序（Insertion-Sort，IS）"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">1. 插入排序（Insertion Sort，IS）</span></span></a></li><li><a class="level is-mobile" href="#2-自顶向下归并排序（Top-down-Mergesort，TDM）"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">2. 自顶向下归并排序（Top-down Mergesort，TDM）</span></span></a></li><li><a class="level is-mobile" href="#3-自底向上归并排序（Bottom-up-Mergesort，BUM）"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">3. 自底向上归并排序（Bottom-up Mergesort，BUM）</span></span></a></li><li><a class="level is-mobile" href="#4-随机快速排序（Random-Quicksort，RQ）"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">4. 随机快速排序（Random Quicksort，RQ）</span></span></a></li><li><a class="level is-mobile" href="#5-Dijkstra-3-路划分快速排序（Quicksort-with-Dijkstra-3-way-Partition，QD3P）"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">5. Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）</span></span></a></li><li><a class="level is-mobile" href="#测量时间与空间占用量"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">测量时间与空间占用量</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四-结果分析"><span class="level-left"><span class="level-item">4</span><span class="level-item">四. 结果分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-大量有序数据（N-20000）"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">1. 大量有序数据（N = 20000）</span></span></a></li><li><a class="level is-mobile" href="#2-大量重复数据（N-20000）"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">2. 大量重复数据（N = 20000）</span></span></a></li><li><a class="level is-mobile" href="#3-大量随机数据（N-20000）"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">3. 大量随机数据（N = 20000）</span></span></a></li><li><a class="level is-mobile" href="#4-少量随机数据（N-1000）"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">4. 少量随机数据（N = 1000）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#五-问题回答"><span class="level-left"><span class="level-item">5</span><span class="level-item">五. 问题回答</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Zylll&#039;s Blog</a><p class="is-size-7"><span>&copy; 2024 Zylll</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">做一名万物学徒。</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>