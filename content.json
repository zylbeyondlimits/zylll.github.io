{"posts":[{"title":"姚期智 - 亿万富翁问题","text":"Solution Mathematical Model该过程是一个非对称加密。Alice 有公钥，有私钥，资产 $i$ 亿元；Bob 有公钥，无私钥，资产 $j$ 亿元。 1. Bob 操作 选取一个大数字 $X$，$E(X) = k$，$D(k) = X$。 令 $m = k - j + 1$，将 $m$ 作为密文传输给 Alice。 2. Alice 操作 计算 $m, \\ m + 1, \\ m + 2, \\ \\cdots, \\ m + 9$，即 $k - j + 1, \\ k - j + 2, \\ k - j + 3, \\ \\cdots, k - j + 10$。 解密：令 $y_u = D(k - j + u)$，不难发现 $y_j = D(K) = X$。 求模：令 $z_u = y_u \\mod P$，其中 $P$ 是一个较大的质数。 保持 $z_1, z_2, z_3 \\cdots, z_i$ 不变，$z_{i + 1}, z_{i + 2}, \\cdots z_{10}$ 加 1。并将 $z_1 \\sim z_{10}$ 重传给 Bob。 3. Bob 检验若 $X \\mod P = z_j$，则证明 $j \\leq i$；若 $X \\mod P \\neq z_j$，则证明 $j &gt; i$。","link":"/2024/03/05/%E5%A7%9A%E6%9C%9F%E6%99%BA-%E7%99%BE%E4%B8%87%E5%AF%8C%E7%BF%81%E9%97%AE%E9%A2%98/"},{"title":"抽象代数笔记","text":"6.1 代数结构代数系统（代数）：非空集合 $S$ 和 $S$ 上的 $k$ 个一元或二元运算 $f_1, f_2, \\cdots f_k$ 组成的系统。记作 $ \\langle S, f_1, f_2, \\cdots, f_k \\rangle$ 。 6.1.1 代数运算设 $A, B$ 是非空集合， $f$ 是从 $A ^ n$ 到 $B$ 的一个映射，则称 $f$ 为集合 $A ^ n$ 到 $B$ 的一个 $n$ 元代数运算。（其中 $n$ 称作该运算的阶）。$+, -, \\ast, \\circ$ 等这些符号加上 普通 的前缀，才代表的是其原来的运算。 运算的封闭性设 $f$ 为集合 $A ^ n$ 到 $B$ 的一个 $n$ 元运算。若 $B \\subseteq A $ ,则称 $f$ 在集合 $A$ 上是封闭的。e.g. 普通减运算在 $\\mathbb N$ 上不封闭。 若称一个运算是某个集合上的运算，则该运算必须满足在这个集合上具有封闭性。 1. 运算性质 - 交换律设 $\\ast$ 为 $S$ 上的二元运算，若 $ \\forall x, y \\in S$ 都有： $$x \\ast y = y \\ast x$$ 则称运算 $ \\ast $ 在 $S$ 上可交换。若已知该运算的运算表，则可通过判断该表是否满足沿主对角线对称，来判断是否满足交换律。 2. 运算性质 - 结合律设 $\\ast$ 为 $S$ 上的二元运算，若 $ \\forall x, y, z \\in S$ 都有: $$(x \\ast y) \\ast z = x \\ast (y \\ast z)$$ 则称运算 $\\ast$ 在 $S$ 上可结合。判断该运算是否满足结合律，不能通过运算表直观的看出来。 3. 运算性质 - 分配律设 $\\ast, \\circ$ 为 $S$ 上的二元运算，若 $ \\forall x, y, z \\in S$ 都有： $$x \\ast (y \\circ z) = (x \\ast y) \\circ (x \\ast z), \\quad 称 \\ast 对 \\circ 左可分配 \\(y \\circ z) \\ast x = (y \\ast x) \\circ (z \\ast x), \\quad 称 \\circ 对 \\ast 右可分配$$ 则称 $\\ast$ 对 $\\circ$ 可分配。 4. 运算性质 - 吸收律设 $\\ast, \\circ$ 为 $S$ 上的二元运算，若 $ \\forall x, y \\in S$ 都有： $$x \\ast (x \\circ y) = x, \\quad 称 \\ast 对 \\circ 左可吸收 \\(x \\circ y) \\ast x = x, \\quad 称 \\circ 对 \\ast 右可吸收$$ 则称 $\\ast$ 对 $\\circ$ 可吸收。若 $\\ast$ 满足交换律，则只需证明一边满足吸收律即可。e.g. 集合中的 $\\bigcup$ 运算对 $\\bigcap$ 运算可吸收。因为 $A \\bigcup (A \\bigcap B) = A$（右可吸收同理）。 5. 运算性质 - 等幂律设 $\\ast$ 为 $S$ 上的二元运算，若 $ \\forall x \\in S$ 都有: $$x \\ast x = x$$ 则称运算 $\\ast$ 在 $S$ 上满足等幂律。 6. 运算性质 - 消去律设 $\\ast$ 为 $S$ 上的二元运算，某个元素 $a \\in S$，若 $ \\forall x, y \\in S$ 都有： $$a \\ast x = a \\ast y \\ \\Rightarrow x = y, \\quad 称a是左可消去的 \\x \\ast a = y \\ast a \\ \\Rightarrow x = y, \\quad 称a是右可消去的$$ 则称 $a$ 关于 运算 $\\ast$ 是可消去的。若 $S$ 中所有的元素都满足消去律，则可说明 $\\ast$ 满足消去律。 $a \\ast x = a \\ast y \\ \\Rightarrow x = y$ 叫做永真蕴含式。箭头左边的式子叫做前件，右边的叫做后件。永真蕴含式表明，若前件成立，则后件一定成立。永真蕴含式的逆否形式也成立。 可消去性可以从运算表中观察到。若 $\\ast$ 满足消去律，则运算表中每一行每一列中都没有相同的元素。 6.1.2 代数常元该代数系统中与运算相关的特殊元素称作代数常元。 1. 幺元设 $\\ast$ 是定义在 $S$ 上的二元运算，若存在元素 $e_l$ (或 $e_r$) 使得 $\\forall x \\in A$ 都有： $$e_l \\ast x = x \\quad （或 \\ x \\ast e_r = x）$$ 则称 $e_l$ (或 $e_r$) 是 $S$ 中关于 $\\ast$ 运算的左（右）幺元。若 $e$ 既是左幺元又是右幺元，则称 $e$ 是 $S$ 中关于 $\\ast$ 运算的幺元。且 $e$ 是 $S$ 上关于 $\\ast$ 的唯一的幺元。 2. 零元设 $\\ast$ 是定义在 $S$ 上的二元运算，若存在元素 $\\theta_l$ (或 $\\theta_r$) 使得 $\\forall x \\in A$ 都有： $$\\theta_l \\ast x = \\theta_l \\quad （或 \\ x \\ast \\theta_r = \\theta_r）$$ 则称 $\\theta_l$ (或 $\\theta_r$) 是 $S$ 中关于 $\\ast$ 运算的左（右）零元。若 $\\theta$ 既是左零元又是右零元，则称 $\\theta$ 是 $S$ 中关于 $\\ast$ 运算的零元。且 $\\theta$ 是 $S$ 上关于 $\\ast$ 的唯一的零元。 3. 逆元设 $\\ast$ 是定义在 $S$ 上的二元运算，$e$ 是 $S$ 中关于 $\\ast$ 运算的幺元。对于 $x \\in S$, 如果存在 $y_l \\in S$ （或 $y_r \\in S$）使得： $$y_l \\ast x = e \\quad （或 \\ x \\ast y_r = e）$$ 则称 $y_l$ (或 $y_r$) 是 $x$ 的左（右）逆元。若 $y \\in S$ 既是左逆元又是右逆元，则称 $y$ 是 $x$ 的逆元。 若 $\\ast$ 运算是可结合的，且对于 $x \\in S$ 存在 $y_l, y_r$ ，则 $y$ 是 $x$ 的唯一的逆元, $y = y_l = y_r$。 6.2 子代数6.2.1 子代数的定义设 $\\langle A, \\ast, \\varDelta, k \\rangle$ 是一个代数系统， $\\ast, \\varDelta$ 分别是载体 $A$ 上的二元运算和一元运算， $k$ 是代数常元。若： $$A’ \\subseteq A \\ A’ 对 \\ast 和 \\varDelta 均封闭 \\ k \\subseteq A’$$ 则称 $\\langle A, \\ast, \\varDelta, k \\rangle$ 是 $A$ 的子代数系统。若 $A’ = A$， $\\langle A’, \\ast, \\varDelta, k \\rangle$ 被称为 $A$ 的最大的子代数。若 $A’ = k$， $\\langle A’, \\ast, \\varDelta, k \\rangle$ 被称为 $A$ 的最小的子代数。最大和最小子代数被称为 $A$ 的平凡子代数。其余的子代数（$A’ \\subseteq A$）被称为 $A$ 的真子代数。 6.3 同态6.3.1 同态的定义设 $A = \\langle S, \\ast, \\varDelta, k \\rangle, A’ = \\langle S’, \\ast’, \\varDelta’, k’ \\rangle$ 两个具有相同构成的代数系统， $f$ 是从 $S$ 到 $S’$ 的一个映射， 且对 $\\forall a, b \\in S$ 满足（先运算再映射 = 先映射再运算）： $$f(a\\ast b) = f(a) \\ast’f(b) \\ f(\\varDelta a) = \\varDelta’f(a) \\ f(k) = k’$$ 则称 $f$ 为由 $A$ 到 $A’$ 的一个同态映射， 简称同态， 记作 $A \\sim A’$。 6.3.2 同态象设 $f$ 是从 $A$ 到 $A’$ 的同态映射，称 $\\langle f(S), \\ast’, \\varDelta’, k’ \\rangle$ 为 $A$ 在映射 $f$ 下的同态象。 6.3.3 同态的分类设 $f$ 是从 $A$ 到 $B$ 的一个映射。 满射：若 $B$ 中每个值都能在 $A$ 中找到其原象，则称 $f$ 是一个满射。 单射：若 $\\forall x, y \\in A, x \\neq y$，都有 $f(x) \\neq f(y)$。则称 $f$ 是一个单射。 双射：既是满射又是双射的映射。 设 $f$ 是从 $A = \\langle S, \\ast, \\varDelta, k \\rangle$ 到 $A’ = \\langle S’, \\ast’, \\varDelta’, k’ \\rangle$ 的一个同态映射。 若 $f$ 是满射的，则称 $f$ 是一个满同态。 若 $f$ 是单射的，则称 $f$ 是一个单一同态。 若 $f$ 是双射的，则称 $f$ 是一个同构映射，简称同构，记作 $A \\cong A’$。 若 $A = A’$，则称 $f$ 为 $A$ 上的自同态。 若 $A = A’$ 且 $f$ 是双射的，则称 $f$ 为 $A$ 上的自同构。 6.3.4 同态的性质设 $f$ 是从 $A = \\langle S, \\ast, \\varDelta, k \\rangle$ 到 $A’ = \\langle S’, \\ast’, \\varDelta’, k’ \\rangle$ 的一个同态映射。那么 $A$ 的同态象 $A’’ = \\langle f(S), \\ast’, \\varDelta’, k‘ \\rangle$。 $A’’$ 是 $A’$ 的子代数。 若 $\\ast$ 在 $A$ 中可交换（可结合），则 $\\ast’$ 在 $A’’$ 中也可交换（可结合）。 若在 $A$ 中 $\\ast$ 对 $\\varDelta$ 可分配，则在 $A’’$ 中 $\\ast’$ 对 $\\varDelta’$ 也可分配。 若 $e$ 是 $A$ 中关于运算 $\\ast$ 的幺元，则 $f(e)$ 也是 $A’’$ 中关于运算 $\\ast’$ 的幺元。 若 $\\theta$ 是 $A$ 中关于运算 $\\ast$ 的零元，则 $f(\\theta)$ 也是 $A’’$ 中关于运算 $\\ast’$ 的零元。 $\\forall x \\in S$, $x$ 对运算 $\\ast$ 存在逆元 $x^{-1}$；则在 $f(S)$ 中，$f(x)$ 也有关于运算 $\\ast’$ 的逆元 $f(x^{-1})$。 6.4 同余6.4.1 同余的定义设代数系统 $A = \\langle S, \\ast, \\varDelta \\rangle$ ， $ \\sim $ 是载体 $S$ 上的等价关系。 $\\forall a, b, c, d \\in S：$ 当 $a \\sim b$ 时，若 $\\varDelta a \\sim \\varDelta b$，则说明等价关系在一元运算 $\\varDelta$ 下是可保持的，称 $\\sim$ 是关于运算 $\\varDelta$ 的同余关系。 当 $a \\sim b, c \\sim d$ 时，若 $a \\ast c \\sim b \\ast d$，则说明等价关系在二元运算 $\\ast$ 下是可保持的，称 $\\sim$ 是关于运算 $\\ast$ 的同余关系。 若 $\\sim$ 在 $A$ 上的所有运算下都是可保持的，则称 $\\sim$ 是代数系统 $A$ 上的同余关系。 等价关系具有对称性、自反性、传递性。 6.4.2 与同态有关的定理设 $g$ 是从 $A = \\langle S, \\ast, \\varDelta, k \\rangle$ 到 $A’ = \\langle S’, \\ast’, \\varDelta’, k’ \\rangle$ 的一个同态映射。若在 $A$ 上定义等价关系 $R$ ： $$\\langle a, b \\rangle \\in R, \\quad iff: g(a) = g(b)$$ 则 $R$ 是 $A$ 上的一个同余关系。 6.5 商代数6.5.1 商代数的定义与性质设代数系统 $A = \\langle S, \\ast, \\varDelta, k \\rangle$，$\\sim$ 是 $A$ 上的同余关系。则称 $A$ 关于 $\\sim$ 的商代数 $A/ ! \\sim \\ = \\langle S/ ! \\sim, \\ast’, \\varDelta’, [k] \\rangle$。其中 $ \\varDelta’[a] = [\\varDelta a], \\ [a] \\ast’ [b] = [a \\ast b]$。 $S/ ! \\sim$ 是集合的集合，即等价类的集合。该集合是 $S$ 的一个划分，即该集合中任意两元素（集合）的交集是空集（因为等价具有传递性）。$\\ast’, \\varDelta’$ 是集合间的运算，$[k]$ 是代数常元的集合。 小结：由等价关系 $R$ 可以得到代数系统 $A$ 的载体的一个划分，以这个划分为新的载体，按照原运算的规则建立等价类之间新的运算，这样得到的代数系统是原代数系统的商代数。 6.6 半群与独异点6.6.1 半群与子半群半群：对于一个代数系统 $\\langle S, \\ast \\rangle$， $\\ast$ 是 $S$ 上的二元运算，若运算 $\\ast$ 是可结合的，则称 $\\langle S, \\ast \\rangle$ 为半群。子半群：设 $\\langle S, \\ast \\rangle$ 是一个半群， $T \\subseteq S$ 且 $\\ast$ 在 $T$ 上是封闭的，那么 $\\langle T, \\ast \\rangle$ 是 $\\langle S, \\ast \\rangle$ 的子代数。$\\langle T, \\ast \\rangle$ 也是一个半群，称为 $\\langle S, \\ast \\rangle$ 的子半群（因为结合律在子代数上可继承）。 6.6.2 独异点与子独异点独异点：含有幺元的半群（含幺半群）。子独异点：满足是原代数系统的子代数，本身是独异点，且在相同运算下与原代数系统有相同幺元，那么称为是原独异点的子独异点。 6.6.3 半群与独异点的等幂元性质设 $\\langle S, \\ast \\rangle$ 是一个半群，若 $S$ 是一个有限集，则必存在 $a \\in S$，使得 $a \\ast a = a$。证明：结合鸽巢原理。 6.6.4 交换半群与循环独异点交换半群（独异点）：在半群（独异点）中，若运算是可交换的，则称此半群（独异点）为交换半群（独异点）。 循环独异点：设 $\\langle S, \\ast, e \\rangle$ 是一个独异点，若 $\\exists g \\in S$ ，则 $ \\forall a \\in S , \\exists k \\in \\mathbb N$ 使得 $a = g ^ k$ （$g ^ k$ 是 $k$ 个 $g$ 做运算的意思），则称此独异点为循环独异点。 （存在一个数能把其他所有数都表示出来）$g$ 称为该循环独异点的生成元，一个循环独异点的生成元个数可以不唯一。 6.7 群6.7.1 群的定义群：设 $\\langle G, \\ast \\rangle$ 是一个代数系统。若 $\\ast$ 运算是可结合的（是半群），并且存在幺元（是独异点），并且 $\\forall x \\in G$，都存在其唯一的逆元 $x ^ {-1} \\in G$，则称 $\\langle G, \\ast \\rangle$ 是一个群。 群的阶数：群的元素个数，记作 $|G|$ 。根据 $|G|$ 可以将群分为有限群和无限群。 6.7.2 群的性质 群中无零元。 （因为零元不可逆，故群中一定不含零元。） 群中每个元素的逆元唯一。 设 $\\langle G, \\ast \\rangle$ 是一个群，对于 $a, b \\in G$，必存在唯一的 $x \\in G$，使得 $a \\ast x = b$。 （即群中任何两个元素都能通过运算相互表示。） 设 $\\langle G, \\ast \\rangle$ 是一个群， $\\forall a, b, c \\in G$，若有 $a \\ast b = a \\ast c$ 或者 $b \\ast a = c \\ast a$，则必有 $b = c$（消去律）。 （因为没有零元，所以可以直接消去。） 设 $\\langle G, \\ast \\rangle$ 是一个群，除幺元 $e$ 外，不可能有任何别的等幂元。 （幺元是唯一的等幂元。） 群 $\\langle G, \\ast \\rangle$ 的运算表的每一行/每一列都是 $G$ 中所有元素的一个置换。 （$G$ 中每一个元素都会在运算表中的每一行/每一列出现，并且只出现一次。） 6.7.3 群中元素的阶设 $\\langle G, \\ast \\rangle$ 是一个群， $e$ 是幺元， $a \\in G$。若存在唯一且最小的正整数 $n$ 使得 $a ^ n = e$，则称 $n$ 为元素 $a$ 的阶（或周期）；否则称元素 $a$ 的阶是无限的。 定理1若群 $\\langle G, \\ast \\rangle$ 的元素 $a$ 拥有一个有限阶 $n$ ，则 $a ^ k = e$ 当且仅当 $k$ 是 $n$ 的倍数。 定理2群中任何一个元素 $a$ 与它的逆元 $a^{-1}$ 都具有相同的阶。 定理3有限群 $\\langle G, \\ast \\rangle$ 中任何一个元素的阶最多是 $|G|$。 6.7.4 阿贝尔群与循环群阿贝尔群：若群 $\\langle G, \\ast \\rangle$ 中 $\\ast$ 运算是可交换的，则称该群为阿贝尔群（Abel 群）或交换群。 循环群：设 $\\langle G, \\ast \\rangle$ 是群，若 $\\exists \\ g \\in G, \\forall a \\in G, a = g ^ i(i \\in \\mathbb I)$，则称 $\\langle G, \\ast \\rangle$ 为循环群。 $g$ 是循环群 $\\langle G, \\ast \\rangle$ 的一个生成元。一个循环群的生成元个数可以不唯一。与循环独异点不同的是，循环群中 $a = g ^ i$ 中的 $i$ 可以取负整数。在这里理解成对 $g$ 先求逆，再进行 $|i|$ 次的运算。 任何一个循环群必定是阿贝尔群。（证明：将元素写成生成元的幂的形式，再证明 $\\ast$ 的可交换性，其中用到了加法是可交换的。） 6.7.5 循环群的性质设 $\\langle G, \\ast \\rangle$ 是循环群，它的生成元是 $g$，$n = |G|$，则： $n$ 是使 $g ^ n = e$ 的最小正整数。 $G = { g ^ 1, g ^ 2, \\cdots, g ^ n = e}$。 定理：循环群的子群必是循环群。 6.7.6 子群和群同态设 $\\langle G, \\ast \\rangle$ 是群， $S$ 是 $G$ 的非空子集。若： $\\forall a, b \\in S, a \\ast b \\in S$ —— $\\ast$ 在 $S$ 上封闭。 $\\forall a \\in S, a ^ {-1} \\in S$ —— $S$ 中所有元素可逆。 $e \\in S$， 其中 $e$ 是 $\\langle G, \\ast \\rangle$ 的幺元 —— $S$ 包含和 $G$ 中一样的幺元。 则称 $\\langle S, \\ast \\rangle$ 是 $\\langle G, \\ast \\rangle$ 的子群。$\\langle G, \\ast \\rangle$ 和 $\\langle { e}, \\ast \\rangle$ 称作 $\\langle S, \\ast \\rangle$ 的平凡子群。（联想到子代数和平凡子代数的概念） 子群的判定1设 $\\langle G, \\ast \\rangle$ 是群， $S$ 是 $G$ 的非空子集。若运算 $\\ast$ 在 $S$ 上封闭，并且 $\\forall x \\in S, x ^{-1} \\in S$，则称 $\\langle S, \\ast \\rangle$ 是 $\\langle G, \\ast \\rangle$ 的子群。 子群的判定2设 $\\langle G, \\ast \\rangle$ 是群， $S$ 是 $G$ 的非空子集。若 $S$ 是有限集，并且 $\\ast$ 在 $S$ 上封闭，则称 $\\langle S, \\ast \\rangle$ 是 $\\langle G, \\ast \\rangle$ 的子群。 子群的判定3设 $\\langle G, \\ast \\rangle$ 是群，$S$ 是 $G$ 的非空子集。若 $ \\forall a, b \\in S, a \\ast b ^ {-1} \\in S$，则称 $\\langle S, \\ast \\rangle$ 是 $\\langle G, \\ast \\rangle$ 的子群。 群同态设 $\\langle G, \\ast \\rangle$ 和 $\\langle H, \\circledast \\rangle$ 是两个群， $h$ 是 $G$ 到 $H$ 的映射。若 $\\forall a, b \\in G$，都有 $h(a \\ast b) = h(a) \\circledast h(b)$，则称 $h$ 是 $\\langle G, \\ast \\rangle$ 到 $\\langle H, \\circledast \\rangle$ 的群同态，$\\langle h(G), \\circledast \\rangle$ 称作 $\\langle G, \\ast \\rangle$ 的同态象。（本质与之前的同态概念相同，先运算再映射 = 先映射再运算） 之前的同态是针对普通代数系统的，群同态的概念只是在代数系统是群的条件上产生的。 群同态的定理群 $\\langle G, \\ast \\rangle$ 的同态象 $\\langle h(G), \\circledast \\rangle$ 是群 $\\langle G, \\ast \\rangle$ 的子群。（证明：最朴素的子群证法） 同态核设 $h$ 是从群 $\\langle G, \\ast \\rangle$ 到 $\\langle H, \\circledast \\rangle$ 的一个同态映射， $e_H$ 是 $\\langle H, \\circledast \\rangle$ 中的幺元。定义： $$Ker(h) = { x | x \\in G \\wedge h(x) = e_{H}}$$ 称 $Ker(h)$ 为群同态映射 $h$ 的核，简称 $h$ 的同态核。 $\\langle Ker(h), \\ast \\rangle$ 是 $\\langle G, \\ast \\rangle$ 的子群。 循环群同态性质设 $\\langle G, \\ast \\rangle$ 是一个循环群，其生成元为 $g$ 。 若 $|G|$ 是无限集，则 $\\langle G, \\ast \\rangle$ 与 $\\langle I, + \\rangle$ 同构。 若 $|G|$ 是有限集且其阶为 $k$, 则 $\\langle G, \\ast \\rangle$ 与 $\\langle N_k, +_{k} \\rangle$ 同构。 6.7.7 陪集设 $\\langle H, \\ast \\rangle$ 是群 $\\langle G, \\ast \\rangle$ 的一个子群。 左陪集：$a \\in G$，集合 $aH = { a \\ast b \\ | \\ b \\in H}$，称为由 $a$ 确定的 $H$ 在 $G$ 中的左陪集。元素 $a \\in aH$ 称为左陪集 $aH$ 的代表元素。 陪集的性质 设 $\\langle H, \\ast \\rangle$ 是群 $\\langle G, \\ast \\rangle$ 的一个子群，$aH$ 和 $bH$ 是其任意两个左陪集。 $aH = bH$ 或 $aH \\bigcap bH = \\phi $。 $|aH| = |bH| = |H|$。 设 $\\langle H, \\ast \\rangle$ 是群 $\\langle G, \\ast \\rangle$ 的一个子群，$a, b \\in G$，$aH$ 是由 $a$ 确定的 $H$ 在 $G$ 中的左陪集。则 $b \\in aH$ 当且仅当 $a ^ {-1} \\ast b \\in H$。 6.7.8 拉格朗日定理设 $\\langle H, \\ast \\rangle$ 是群 $\\langle G, \\ast \\rangle$ 的一个子群，则： $R = { \\langle a, b \\rangle \\ | \\ a \\in G \\wedge b \\in G \\wedge a ^ {-1} \\ast b \\in H}$ 是 $G$ 中的等价关系，且有 $[a]_R = aH$。 若 $G$ 是有限群，$|G| = n$，$|H| = m$，则 $m \\ | \\ n$。 拉格朗日定理的推论 任何质数阶的群没有非平凡子群。 设 $\\langle G, \\ast \\rangle$ 是 $n$ 阶有限群，则 $\\forall a \\in G$， $a$ 的阶数必定是 $n$ 的因子，且 $a ^ n = e$。 一个质数阶的群必定是循环群，且任何与幺元不同的元素均可作为生成元。 6.8 环和域6.8.1 环若代数系统 $\\langle A, +, \\cdot \\rangle$ 满足： $\\langle A, + \\rangle$ 是阿贝尔群（$\\langle A, + \\rangle$ 是群且 $+$ 在 $A$ 上可交换）。 $\\langle A, \\cdot \\rangle$ 是半群（ $\\cdot$ 在 $A$ 上可结合）。 乘法 $\\cdot$ 和加法 $+$ 是可分配的。即 $\\forall a, b, c \\in A$，有：$$a \\cdot (b + c) = a \\cdot b + a \\cdot c \\ (b + c) \\cdot a = b \\cdot a + b \\cdot c$$ 则称 $\\langle A, +, \\cdot \\rangle$ 是环。 环的定理设 $\\langle A, +, \\cdot \\rangle$ 是环，$\\theta$ 是 $+$ 的幺元。则 $\\forall a, b, c \\in A$，有： $a \\cdot \\theta = \\theta \\cdot a = \\theta$（$\\theta$ 同时也是 $\\cdot$ 的零元） $a \\cdot (-b) = (-a) \\cdot b = -a \\cdot b$ $(-a) \\cdot (-b) = a \\cdot b$ $a \\cdot (b - c) = a \\cdot b - a \\cdot c$ $(b - c) \\cdot a = b \\cdot a - c \\cdot a$ $-a$ 是 $a$ 的加法逆元，将 $a + (-b)$ 记作 $a - b$。 特殊的环设 $\\langle A, +, \\cdot \\rangle$ 是环: 交换环：若运算 $\\cdot$ 是可交换的。 含幺环：若 $\\langle A, \\cdot \\rangle$ 含有幺元。 含零因子环：$\\theta$ 是 $+$ 的幺元，若 $\\exists a, b \\in A, a \\neq \\theta, b \\neq \\theta$，使得 $a \\cdot b = \\theta$，则称 $a, b$ 是零因子，称 $\\langle A, +, \\cdot \\rangle$ 是含零因子环。 整环：$\\langle A, \\cdot \\rangle$ 是可交换独异点且无零因子。 整环的定理设 $\\langle A, +, \\cdot \\rangle$ 是环，$\\theta$ 是 $+$ 的幺元。$\\langle A, +, \\cdot \\rangle$ 无零因子当且仅当 $\\langle A, +, \\cdot \\rangle$ 满足可约律（即 $\\forall a, b, c \\in A, c \\neq \\theta$，若 $c \\cdot a = c \\cdot b$，必有 $a = b$）。 6.8.2 域在代数系统 $\\langle F, +, \\cdot \\rangle$ 中， $\\theta$ 是 $+$ 的幺元，若： $\\langle F, + \\rangle$ 是阿贝尔群。 $\\langle F - { \\theta }, \\cdot \\rangle$ 也是阿贝尔群。 乘法 $\\cdot$ 和加法 $+$ 是可分配的。 则称 $\\langle F, +, \\cdot \\rangle$ 是域。 域的定理域一定是整环。可以通过整环的概念来定义域：设 $\\langle F, +, \\cdot \\rangle$ 是整环，$|F| &gt; 1$，且 $\\langle F - { \\theta }, \\cdot \\rangle$ 是群，则 $\\langle F, +, \\cdot \\rangle$ 是域。 有限整环一定是域。","link":"/2023/10/18/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/"},{"title":"About me","text":"今年大四，计算机科学与技术专业在读。Xidian University ➡️ Xi’an Jiaotong University.这个博客主要是用于记录自己学习生涯中的笔记、平时阅读到好书好句时的一些摘抄、以及一些随笔。后期可能会上传一些自己的摄影作品。希望自己能做一个万物学徒，一个一直在思考的人。","link":"/2024/11/13/About%20me/"},{"title":"大数据安全与隐私 - Lab2 - 数据安全检索","text":"实验环境准备利用 pcl 库中的模块来实现 K-D Tree。 安装 pcl 库。 1brew install pcl Cmake 相关配置。 12cd ./testtouch CMakeLists.txt CmakeLists.txt： 12345678cmake_minimum_required(VERSION 2.6 FATAL_ERROR) # 选择cmake版本project(PCLtest) # 给工程命名find_package(PCL REQUIRED) include_directories(${PCL_INCLUDE_DIRS})link_directories(${PCL_LIBRARY_DIRS})add_definitions(${PCL_DEFINITIONS})add_executable(PCLtest main.cpp)target_link_libraries(PCLtest ${PCL_LIBRARIES}) test： main.cpp: 实验源代码。 1234mkdir build &amp;&amp; cd ./buildcmake ..make./PCLtest 安全查询的实现：保序加密（分段映射） 定点数转换：将小数转换为定点数。为了保留小数点后的6位精度，代码将原始的浮点数乘以1e6，将其转化为整数。这样可以确保在段内的随机化不会造成显著的精度损失。同时，分段数目也影响着精度。 分段计算：计算原始整数值所属的分段。分段是基于整数值与分段大小的比率计算的。 随机化：在分段内加入随机偏移，增加保序加密的安全性。这样，虽然数据的顺序保持，但值本身有一定的随机性。因为随机偏移的原因，解密的值和加密前的值可能略有不同。这种保序加密通常用于需要顺序查询但同时又需要保持一定随机性和安全性的场景。本质是一种近似的安全查询。 K-D Treek-D Tree 是一种可以高效处理 $k$ 维空间信息的数据结构。可应用于多维空间数据的范围搜索和最近邻搜索。 最近邻搜索由于 K-D Tree 的性质，通过二叉搜索可以很快找到最邻近的近似点，但最邻近肯定距离查询点更近，应该位于以查询点为圆心且通过叶子节点的圆域内。 为了找到真正的最近邻需进行 回溯 操作：算法沿搜索路径反向查找是否有距离查询点更近的数据点。回溯的过程中，判断在该父节点的其他子节点空间中是否有距离查询点更近的数据点。 即以查询点为圆心，以查询点到最邻近的近似点的距离为半径，画圆。若发现该圆并不和某平面相交，则代表不用进入该父节点的右子空间中去搜索。","link":"/2024/05/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9A%90%E7%A7%81-Lab2-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%A3%80%E7%B4%A2/"},{"title":"大数据安全与隐私 - Lab1 - 现代密码学基础技能","text":"1. 实验内容模拟实现 DH 密钥交换协议（基于大素数进行算法实现），并生成会话密钥。利用会话密钥对字符串进行正确的加密和解密，且需要使得相同内容每次发送的密文不同。 2. 实验原理2.1 Diffie–Hellman 密钥交换协议利用离散对数问题的特性（ $G$ 是一个单位元为 $1$ 的、其中一个生成元为 $g$ 的乘法循环群）： Alice 和 Bob 想要通过对称加密来传输信息，现他们需要协商那个用于后续加密的密钥。 以下运算默认在模 $p$ 意义下进行。 在整个过程中，$g$, $g ^ a$, $g ^ b$, $p$ 都作为公开信息在信道上传输，有被 Eve 获取到的可能性。但很难从这些信息推出 $a$ 与 $b$。$g ^ {ab}$ 就作为那个协商好的密钥。 123456789101112131415161718192021222324252627282930# generate_large_prime函数，用于生成大素数def generate_large_prime(bits): while True: # 生成一个 bits 位的随机数作为候选素数 candidate = random.getrandbits(bits) # 调用 nextprime 函数检查候选数是否为素数，并返回下一个素数 prime_candidate = nextprime(candidate) if prime_candidate.bit_length() == bits: return prime_candidate# 使用 Diffie-Hellman 密钥交换协议生成两个大素数g = generate_large_prime(1024) # prime1: gp = generate_large_prime(1024) # prime2: pprint(&quot;\\nThe 1st 1024-bit big prime number is: &quot;, g)print(&quot;\\nThe 2nd 1024-bit big prime number is: &quot;, p)a = randint(2**10, 2**20)b = randint(2**10, 2**20)x = pow(g, a, p) # x = g ^ a % py = pow(g, b, p) # y = g ^ b % pkeya = pow(y, a, p) # keya = ((g ^ b) ^ a) % p = (g ^ ab) % pkeyb = pow(x, b, p) # keyb = ((g ^ a) ^ b) % p = (g ^ ab) % pprint(&quot;\\nA's secret key is:&quot;, keya)print(&quot;\\nB's secret key is:&quot;, keyb)# 检查双方的密钥是否相同，如果相同则表示 Diffie-Hellman 密钥交换成功if keya == keyb : print(&quot;\\nA's secret key is equal to B's secret key.&quot;) print(&quot;\\nDiffie-Hellman key exchange succeed.&quot;) 2.2 AES 加解密AES 加密算法在该实验中通过 Crypto.Cipher.AES 模块实现，具体使用的是 CBC（Cipher BlockChaining）模式。 AES 是一种分组加密算法，它将明文分成固定大小的块，然后使用相同的密钥对每个块进行加密。本次实验中 AES 密钥的长度为 256 位（使用 SHA256 方法），分组块的长度为 128 位。 CBC 模式通过将前一个密文块的加密结果（除了第一个块，使用初始化向量IV）与当前明文块进行异或操作后再加密，从而增加加密的复杂性和安全性。这种模式可以有效防止相同明文块产生相同的密文块，提高了安全性。 代码中还引入了 pad 与 unpad 功能。使用他们是为了确保 AES 加密和解密操作的正确性和完整性（AES 算法要求加密的数据必须是固定大小的块）。 12345678910111213141516171819202122232425# generate_key函数，用于从共享密钥生成 AES 密钥def generate_key(secret): # 使用 SHA-256 散列算法对共享密钥进行散列，然后返回散列值作为 AES 密钥 key = hashlib.sha256(secret.encode()).digest() return key# encrypt_message函数，用于加密消息def encrypt_message(message, key): # 使用 AES 算法和 CBC 模式创建一个新的加密器实例 cipher = AES.new(key, AES.MODE_CBC) # 对消息进行填充，然后使用加密器进行加密 ciphertext = cipher.encrypt(pad(message.encode(), AES.block_size)) iv = cipher.iv return iv + ciphertext# decrypt_message函数，用于解密消息def decrypt_message(encrypted_message, key): # 从加密的消息中提取 IV 和密文 iv = encrypted_message[:AES.block_size] ciphertext = encrypted_message[AES.block_size:] # 使用 AES 算法和 CBC 模式创建一个新的解密器实例 cipher = AES.new(key, AES.MODE_CBC, iv) # 对密文进行解密和去填充，然后返回解密后的消息 decrypted_message = unpad(cipher.decrypt(ciphertext), AES.block_size) return decrypted_message.decode() 3. 实验结果 上面两个结果表明，可以选择命令行手动输入/本地文件输入想要加密的信息。程序成功生成了两个大素数，且在此基础上计算出来的 Alice 与 Bob 的密钥（共享密钥）相同，说明成功共享了一个用于后续加密的密钥。 后续给出了 AES 的加密结果、解密结果，解密结果与输入的内容一致。 4. 实验心得Python 中提供了很方便的库，让复杂的加密过程得以被轻松的实现。 本人只实现了对文本文件的加解密，可以提升的地方包括：支持其他文件类型的加解密（如图片、pdf等）、支持将加密结果无差错的保存至本地的文件中。 $(document).ready(function() { $(\"#basicExample\").justifiedGallery({ rowHeight : 150, margins : 5 }); });","link":"/2024/04/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9A%90%E7%A7%81-Lab1-%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"},{"title":"「加缪手记」摘抄","text":"10.15序：写下生命中对思考创作有意义的当下片段，本质上即是赋予无形体验以有形的存在和表现形式。 8月的雷雨天。热风和乌云。但东方却透出一抹晴蓝，轻盈而剔透。叫人无法直视。这样的蓝，对眼睛和灵魂来说都是一种折磨。因为美会让人受不了。美会让人万念俱灰，因为我们是多想要让这种刹那的永恒一直持续下去。 年轻时，我会向众生索要他们能力范围之外的：友谊长存，热情不灭。如今，我明白只能要求对方能力范围之内的：做伴就好，不用说话。而他们的情感、友谊和操守，在我眼中仍完全是一种奇迹，是恩惠的完全表现。 时间会过得这么快，是因为我们没办法在里面做什么记号。类似月亮是在天顶还是在地平线之上类的。这就是为什么那些青春岁月如此漫长，因为太丰盛，而年华老去时则光阴似箭，因为一切都已成定局。譬如我就发现几乎不可能盯着一根指针在钟面上绕五分钟，而不会感到漫长和厌烦的。 一阵颇带劲的微风从山上吹下来，翻搅着青草与阳光。令人赞叹之光从天而降。底下是光滑无痕的海面，正露着它的蓝色牙齿在微笑。我站在风里，头顶上的太阳只能晒到一边的脸庞。我凝视着这个独一无二的时刻流逝，不晓得该说些什么。 10.16有时候我也需要写下一些自己也不太明白，但却正好可以证明我有个无法羁束的内在的东西。 他每天都到山上去，又默默地回来，头发上都是草，身上都是一整天下来的刮痕。每一次都是无须勾引就被诱惑了。对这个不友善的地方，他内心的抗拒逐渐在减弱。他终于可以想象自己是棱线上那株孤杉背后的多多白云，是那漫山遍野、有着粉红斑点的柳叶菜、花楸和风铃草。他让自己融入了这个嶙峋的芬芳国度。登上遥不可及的山巅时，眼前豁然一片无际的风光，但他内心初生的爱意并未因此获得舒缓，而是暗自和这个不仁的天地订立某种约定，两张刚强倨傲的脸庞之间的停战协议，像敌人在互相威吓，而非朋友间的全然信赖。 在这个溢满繁星的夜里，他伸出手在夜空静谧无边的脸上比画着。他一只胳膊一挥，就把这颗明星和另外那颗时隐时现的星星分开了，一束束的星辰和一朵朵的云，就随着他的挥洒散落下来。于是天上有一池被他搅乱的水，而围绕着他的那座城市，宛如一顶缀满贝壳的华丽斗篷。 人在马赛，幸福和悲哀——在我内心最深处。我喜爱的繁华都市。但同时这孤独的苦味。 灿烂宣泄的阳光。摩纳哥的夹竹桃和繁花遍地的热那亚。利古里亚海岸线上的蓝色夜晚。我的疲倦和这股想哭的冲动。这种孤单和这份想要爱的渴望。比萨，一个腼腆而敏感的城市。夜里，在无人的街道上，它和我靠得这么近，我在街上漫游，想要流出来的眼泪终于决堤了。我内心那道伤口也开始愈合了。 10.17某些事物、某些生命正在等着我，而我当然也在期待着，用我所有的力量和悲情渴望着。 也许我眼前的景物已经被好几百万只眼睛注视过了，但对我而言，它宛如这世界浮现的第一抹微笑。这个世界很美，一切尽在其中。它耐心地宣扬它的伟大真理：那些所谓的精神和心灵，其实都是虚空。而在这个由骄阳下的发烫石头，晴空下更显高大的柏树所界定出来的、独一无二的天地中，“正确”的意思是“无人的大自然”。它带着我直到尽头。它心平气和地否定了我。而我，心悦诚服地，朝着某种圆融的智慧前进——如果我不要这样热泪盈眶，如果我想要号啕大哭的诗心未曾令我将这世界的真理抛却脑后。 舔舐自己的生命，仿佛那是一颗麦芽糖，塑造它，磨砺它，爱它。 我一定会努力将这场和自己的面对面一直延续到底，让它照见我在今生今世中的每一张脸，即使必须付出难以负担的寂寞代价亦在所不惜。我会竭尽全力去达成某个境界，在那儿和我的所爱会合，接着，我俩将以最大的热情去做那些构成我每日生活意义的事。 脸上交织着泪光和阳光的人生，没有盐巴的人生和热石头，一如我所爱、所渴望的人生，我一面怀想着，觉得似乎我所有绝望和爱的力量都因此集合起来了。 10.18艾尔凯达墓园。阴霾的天，满山的白纹和对面的大海。潮湿的土壤和树木。白色墓碑间的鸽子。一朵孤单的天竺葵，颜色难说是粉红还是红。一股迷茫而沉默的巨大悲伤，让死亡那张美丽纯洁的脸庞变得亲切起来。 他说：“每个人生命中都要有爱，一种大爱，因为这样就可以有借口不用去面对那些令人不堪负荷、说不出缘由的绝望。” 他轻轻咬着她的唇，然后，一连好几分钟，嘴对着嘴，吸吮着这令他心神荡漾的温热，仿佛整个世界都拥进怀里了。至于她，像个溺水的人似的抱着他，在这个被人推下去的黑洞里载沉载浮，那两片唇被推开后又会立刻黏上来，她于是再度坠入一片又冷又黑、宛如一群天使般让她浑身着火的水中。 10.25这个世界的悲惨和伟大：不给我们任何真相，但有许多爱。荒谬当道，爱拯救之。 尼采：“当我们见到美的时候心里想要的是什么呢？希望自己也是美的。我们可以想象有多少快乐都寄托在上面，但这是个错误。”（《人性的，太人性的》） 我们所感受到的情感并不会改造我们，但是会让我们有那种想要改变的念头。所以爱并不能让我们不再自私，却可以令我们对此有所察觉，并让我们开始向往一个没有自私的遥远国度。 艺术家和艺术作品。真正的艺术作品是那种点到为止的。一个艺术家的整体经验和他的想法、人生（就某种意义而言即他的“系统”——除掉这个字的系统性意涵的话）之间，有着某种关联，而作品正是这种经验的反映。如果艺术作品把整个经验都讲出来，还包上一层文艺的流苏，那么此一关联就是恶劣的。但如果艺术作品只是从整个经验中切削下来的一小块，像钻石的一个切面，内蕴的光芒将无穷扩散。第一种是超载的文学。第二种则是沃土般的作品，那些不言而喻的经验正暗示着它丰富的内容。问题在于如何取得这种超出写作技巧的处世之道（不如说是经验谈）。到头来，伟大的艺术家其实就是一个了不起的活人（“活着”在这里亦指思考生命——或说是经验和因而产生的意识之间的那种微妙关系）。 他躺下来，傻笑，两只眼睛闪闪发光。她觉得自己所有的爱都哽在喉头，热泪盈眶。她扑向他的双唇，泪珠都让两人的脸庞挤碎了。泪水也流进了她的嘴里。而他，他咬着这两片咸咸的嘴唇，像是在咀嚼他们爱情里的苦涩。 火车上的小情侣。两个都长得不好看。她拉着他，笑吟吟的，撒娇，撩拨他。而他，两眼无神，因在大庭广众之下被一个他并不引以为傲的女人爱着而感到尴尬。 今天，如果我试着去把这独特的感动说清楚，我可以从中看到很多东西。当然，这样的喜悦首先来自让娜——来自她身上的香水味，她紧紧扣着我手腕的手，一些我可预期的表情。但还有那些突然光芒四射的商店，在一个平常伸手不见五指的城区里，行色匆匆，手上提着大包小包的行人，街上孩子的欢笑声，一切都有助于把人从他的原本的孤独世界里拉出来。那些夹心巧克力的银色包装纸就是一种征兆，意味着一个模糊却嘈杂的黄金时期，正在向一些简单的心灵打开，于是让娜和我又依偎地更紧了。也许当时我们都模模糊糊地感觉到了那种独一无二的、当一个人跟自己的人生终于取得妥协时的幸福。通常是我们在一个爱已无立足之地的世界里，带着那片被我们用爱情施了魔咒的沙漠到处游走。而在那几天里，我们觉得当我们手牵手时，心中升起的那把热情，和在橱窗里、在对儿女牵肠挂肚的工人心里，以及在这12月冰冻而纯净的天空深处闪烁的，是一样的火焰。 天气只好一半：有云也有阳光。和谐的地方。只要一大块天，就能让最紧张的心平静下来。 从圣塔克鲁斯看米尔斯克比尔，给人一种雄伟感。壮观得毫不温柔。 10.27这棵柏树上饱吸的金色阳光艳澄欲滴，感觉仿佛有一股黄色汁液，从这树的黑色心底涌上来，流过它每一根短短的树枝直到末梢，然后一条条长长的浅褐色就沿着那些绿油油的叶片淌下来。 …就像有人动不动就喜欢拿铅笔在书上画线，似乎这样可以显示出该读者很有品味，很有智慧的样子。 战场上。人们评估着每一条战线各自的危险程度。“我的这条危险性最高。”在全面的沉沦之中，他们还能分高下。他们就靠这个渡过难关。 爱伦·坡的四大快乐要件。 （1）户外生活。 （2）有人爱。 （3）放开一切野心。 （4）创造。 大家都会问战争在何处——那种惨不忍睹的场面在哪里？然后意识到自己其实知道答案，战争就在我们心里。战争对大部分的人而言，是那份不自在，那种被迫做出的选择。选择出征的后悔自己勇气不足不敢缺席。选择缺席的则自责不能和其他人同生共死。战争在此，真真切切，而我们还在蓝天里、在世间的不仁中遍寻它。它就在身为战士和非战士的可怕孤寂里，在人人感同身受的屈辱和绝望里，在那种随着日子流逝，人们脸上愈来愈明显的卑鄙和龌龊里。牲畜横行的时代开始了。 我们在众生身上已经可以感受到这股愈来愈高涨的仇恨和暴力。他们心中的纯真已荡然无存。再也没有什么是无价之宝了。他们的想法都一样。路上碰到的都是禽兽，一些看起来很像动物的欧洲脸。这个令人作呕的世界和这股全球风行的昏庸愚昧，勇气变得微不足道，伟大可以仿冒，荣誉感逐日式微。 巴黎之春：某个预兆或栗树上一颗芽孢，人心就开始痒了起来。在阿尔及尔，春来得粗暴多了。这里不只是一颗玫瑰花苞，而是一千颗玫瑰花苞，在某天清晨，突然让你无法呼吸。在这里，我们不是被某种难以捕捉的热情闪过脑际，而是教千百种铺天盖地汹涌而至的香气和色彩贯穿全身。这里当道的不是敏感纤细，而是被突袭的身体。 10.30夜晚，在“两大奇景”的露天咖啡座上。我们可以隐约听见海在夜深处的悸动。橄榄树的微颤和从地面冒上来的雾气。冒出海面的岩石上立满白色海鸥。灰沉沉的一群，被翅膀上的雪光照亮了，宛如一个个晶莹的漂冢。 小说。故事在一片灼热而碧蓝的沙滩上展开，两个有着古铜色皮肤的年轻人——海水浴、浪花和日光的嬉戏——夏天夜晚，滨海公路上的果香和阴影深处飘来的雾气——轻衫中自由自在的身躯。吸引力，一颗17岁的心内的秘密微醺。同上。另外一个在寒冷的暴风雨夜开始的故事，仰躺在地，在一片丝柏的中间，天上流动着星星和云。刚开始这并非出于爱，而是一种活下去的欲念。然而，在那座正方形的盖在海上面的大房子里，当这两幅躯体结合在一起，于逆风登高之后紧紧相拥，听见大海那沉闷的呼吸声从地平线彼端传进这个与世隔绝的房间里时，爱情真的是如此遥远吗？在这个奇妙的夜晚，爱的希望和雨水、天空和大地的沉寂是紧紧结合在一起的。两个因大自然而结合的生命之间的微妙平衡，两人共同的那种对一切非此时此地者的漠视，让他们看起来很像。另外这一个仿佛是某种舞蹈的时刻，她穿着有设计的礼服，他则是全套舞衣。 从滨海公路上看过去，那些悬崖是如此之高，以至于眼前的风景因为太珍贵了，竟予人一种虚幻感。人类全被从里面赶了出来，而那种杳无人迹的程度，让这么沉重的美宛若来自另外一个世界。 “哦，我的灵魂，不要向往不朽的生命，但要穷尽一切的可能性。” 海在下面低嗥。但阳光、微风、阿福花的洁白、天上那种已经硬化的蓝，一切都让人想到夏日，它那金黄色的青春，那些女孩男孩的古铜色肌肤，初生的激情，长时间的日晒和傍晚骤然到来的温煦。还能赋予我们这个时代什么其他的意义，除了这高原的启示之外：一边是生，一边是死，在这两种美之间的，是忧郁。 奥兰。诺塞谷：沿着两边枯干而灰尘漫扬的坡地慢慢走。日头下的地面开始龟裂。石头色的乳香黄连木。头顶的天，按时地将它储备的热与火热倾泻而下。渐渐地，黄连木愈来愈高大，颜色也转绿了。走了很长一段路之后，黄连木渐渐被橡树取代，一切都变高长大也和缓了下来，然后，在一个急转弯处，一片开满花的杏林：像是给眼睛喝的凉水。一个宛如失乐园的小山谷。可以眺望大海的山坡路。车子能通但人迹罕至。现在上面都是花。雏菊和毛茛铺出了一条又黄又白的路。 释加牟尼在荒漠中多年，一动不动，眼睛望着天空。连神祇们都妒忌这种智慧和这磐石般的宿命。在他那张开的僵硬的手里，有燕儿来筑巢。但某天，它们展翅而去，一去不返。而那曾经令他内心之渴望与意志、荣耀与痛苦全部寂灭了的东西，开始分泌泪水。石头于是长出了花。 风，这世上罕见的干净东西之一。 11.1一旦做出了荒谬的结论并愿意接受这样的人生，人就会发现意识是世界上最难把持的东西。所有的状况几乎都在跟它作对。事关如何在一个分崩离析的世界里保持清醒。人于是发现，即使没有了上帝，真正的问题还是在于如何解决心理上的混乱（荒谬的作用实际上只会对精神和物质世界的形而上层面造成混乱）并得到内心的平静。他会发现未曾经过严格训练，不知如何与外界取得协调的话，内心就不可能获致平静。所以要去建立的，是尘世生活规范。过去的人生（工作、婚姻、以前的想法等等），那些已发生之事，都会带来阻碍。不规避此问题的任一成因。 海涅的墓志铭：“他喜欢布伦塔河的玫瑰。” 人永远都有一套哲理来解释自己为何缺乏勇气。 11.5面包总管。日出之前，在高耸丘陵上，那些冷杉和底下簇拥着的林涛仍浑然一体。接着，太阳从后面很远的地方把树梢全染成金色。于是在尚未褪色的天空下，仿佛有一整群头上插着羽毛的野蛮人，从山坡后面冒出来。太阳愈高，天空愈澄澈，冷杉也跟着长大，野蛮部队看似步步进逼，集结出一大片闹哄哄、准备发动攻击的羽毛。然后，当太阳爬得够高时，整面山坡上的冷杉一下子全被照亮了。看起来就像野人们正往谷底狂奔而去，一场剧烈而短暂的战斗已然开始，白日的蛮族即将对夜之冥思的残部展开驱逐。 面包总管。9月的第一场雨，伴随着一阵把黄叶打落大雨中的轻风。那些叶子会先在空中一阵飘荡，直到叶片上乘载的雨滴重得突然将它们压倒在地。如果风景很普通，像这里，反而让人更能察觉到四季的变换。 “在床尾，因这临终前的每一声喘息而抽搐，没有哭泣但偶尔会被眼泪湿透，我母亲看起来就像一片任凭风吹雨打，饱受摧残的叶子。”——盖尔芒特 10月。犹然青翠的草地上落叶枯黄。一阵急促而有力的风，用有声的阳光，在那片绿色的草原砧板上打造出一道光芒，里头群蜂嘈杂，声音一直传到我这边。红之美。壮丽、有毒和孤单，像橘红色一样。 相较于天才，这么拼命地努力就如蟋蟀那断断续续的飞行之于燕子的翱翔。 “偶尔，在受够了这种听令于意志的日子，眼见着这件不许分心不许软弱，刻意忽略情绪和外界的工作逐渐完成，啊！那突如其来的是何等的懒散，我怀着的又是何等的解脱感，一头栽进这些日子以来一直陪伴着我的绝望之中。何其希望，何其渴求再也没什么需要建立的，并放弃这件作品，和我这张必然是它捏塑而变得严苛的脸。我曾经也会爱，会后悔，会有欲望，总之我也曾经是个正常人……”“……夏日荒漠般的天空，我如此热爱的大海，还有那些迎上来的唇。” 秋天的森林里，山毛榉就像一块块金黄色斑点，孤立在树林边缘上的，看起来就像从一片大蜂巢淌流出来的金色蜂蜜。 秋天，这片景色里的叶子全盛开了——樱桃树成了大红，槭树是黄的，山毛榉是古铜色的。草原上覆满了这第二春之千朵焰火。 一位作家首先要学会的技巧，就是如何将他感受到的转换成他想要让人感受到的。前面几次的成功都是偶然。但接下来偶然一定要被才情所取代。所以说天才的崛起有一部分须归功于运气。 我高坐船头，继续着这趟在漠然国度里一动不动的航行。至少需要整个大自然和这种冬日为太热情的心所带来的白色和平——才能安抚这颗为苦恋所吞噬之心。我望着天空中那片越来越膨胀、否认了一切死亡预兆的光。未来的象征，终于出现在我这如今只知追忆过往之人的顶上。闭嘴吧，肺！大口大口地吞下这苍白而凛冽、可以滋养你的空气。别再吵了。愿我无需再被迫听着你那缓慢的腐朽——愿我终于能够朝向……","link":"/2023/10/15/%E3%80%8C%E5%8A%A0%E7%BC%AA%E6%89%8B%E8%AE%B0%E3%80%8D%E6%91%98%E6%8A%84/"},{"title":"2019THU创客营游记","text":"Day 0昨天刚刚经历了第一次月考，上午经历了惨痛的试卷讲评，内心压抑QAQ… 通知的中午在一中后门集合，于是上午上了4节课后就跑回家拿行李箱去了…还好没迟到… 做着一辆超载的别克商务车，前往地窝堡国际机场。 在车上认识了一些高二的学长，聊的还挺开心。 到机场后终于看到了许多熟悉的小伙伴，总算不是那么的孤独尴尬了… 候机中： 因为去的时候没有坐在靠窗户的位置，因此没有拍照。 许久没有做过飞机了，这种久违的感觉很奇妙。 飞机餐是牛肉米饭，挺烫的，味道不错。 4个小时，看了一部不错的电影，写了一会代码，读了一会书，就这样度过了。 飞机下降时，感到自己的眉骨附近疼的要命，难受万分。下飞机后查了一下说是什么航空性鼻窦炎…因为自己之前也一直在感冒，后面不疼了也就没管了。 Arrived. 到了北京，感觉温度和这边其实差距不大，晚上吹着微风，还挺舒服。 做了1个小时的大巴，写了一个小时的代码，度过了这无聊的时间。 夜宵+早餐： 双人间，和我住一起的刚好是我在去机场路上认识的一个高二的，至少没那么尴尬啦。 当时没什么食欲，没吃什么东西就准备睡了，结果室友和他的朋友点了麦当劳的外卖，顿时饿了… Day 1清晨的北京： 很早就起床，前往清华大学。 昨晚没睡好，在车上一直睡… 街景： 到达李兆基科技大楼 然后就是抽签分组，签名墙留名。 会场： 之前看到好多妹子，想着我们这一组应该…男女比例正常… 结果…四个男的… 还有一些奇葩的：szy他们组只有他一个男的等等 果然抽签的方式…哎… 开营仪式：","link":"/2019/04/27/2019THU%E5%88%9B%E5%AE%A2%E8%90%A5%E6%B8%B8%E8%AE%B0-updating-BeyondLimits/"},{"title":"浅谈高中生物”碱基对确定，求DNA最多种数”问题","text":"前言这个问题在高中生物中，并不会研究的那么深刻。 所以正式做题时还是应该按照老师的教导，避开这个“雷区”。 1.问题发现在高中生物-遗传与进化-基因的本质学习中，有一个十分经典的问题。 即：给定碱基对数n，不限定每种碱基(A,C,G,T)的个数，求出最多的DNA种数。 在所有的教材，辅导书，以及老师的授课过程中，对于这个问题的答案，一般都是$4^{n}$或者$ \\frac {4^n} {2}$。 对于$4^n$的思路，即每个位置有$4$种碱基对可能，一共有$n$组，根据乘法原理，故为$4^{n}$。 对于$\\frac {4^n} {2}$的思路，即在上一种思路的基础上，考虑到有重复的情况，便除了个2​。 但是，@thorn,@opethrax以及本人的对于这些答案深感怀疑，于是我们便手算了当碱基对数为$2$时的所有情况。 利用计算机程序进行打表，以及查询有关$DNA$的资料后，最终我们确定当n=2时，结果理应为10​。 这个答案都不能用上面的公式解答，于是我们继续思考探索。 2.深入探究通过@opethrax同学辛苦的打表，观察，他发现存在一些情况被忽略。 原先我们认为，一个$DNA$分子拥有$3’$与$5’$段，$3$代表三号碳，$5$代表五号碳。 如下图，从两条链的$3’$端分别扫描，一种序列最多被统计到$2$次。 一个是AGCTA​，另一种是TAGCT。 但是，存在一种$DNA$分子，从其两条链的$3’$端分别扫描，结果相同。 如下图： 都为TCGATCGA。 所以这种情况下，具有这种性质的$DNA$会被少统计一次。 且我们不难发现，满足这种性质当且仅当$DNA$链的长度为偶数（如图一，若为奇数，会出现不对称的情况，即不满足这种性质）。 那么我们分类讨论，之前那个$\\frac {4^n} {2}$的公式，可以在n​为奇数时使用。 对于n​为偶数的情况，我们要在原公式的基础上，加上少统计的个数。 现在的问题，即是寻找拥有这种特殊性质的链的个数。 不难发现，一条链的$3’$端的$1$号碱基到该链的第$\\frac n 2$号碱基，如果和另一条链的$3’$端的$1$号碱基到该链的第$\\frac n 2$号碱基相同，剩下的部分通过碱基互补配对原则，可以保证相同。 下图黑的部分是我们自己确定的一条排列，红色部分是根据碱基互补配对原则形成的。 我们可以把这个理解为一种中心对称。 所以我们只需要构造出一条链中一半的排列，然后按照中心对称放到另一条链的$3’$端，剩下那条按照碱基互补配对原则填充即可满足这种性质。 所以我们不难得出，这种情况下，会有$4^{\\frac {n}{2}}$条链会被少统计一次。 至此，我们可以得出公式：$$a_n=\\begin{cases}\\frac{4^n}{2}\\ \\ \\ \\ \\ \\ \\ \\ n=2k+1\\\\frac{4^n+4^{\\frac{n}{2}}}{2}\\ n=2k\\ \\ (k\\in N^*)\\end{cases}$$这个式子经过打表以及oeis.org的确认，结果正确。 3.声明与感谢其实$DNA$的结构远比人类脑海中想象的要复杂的多，这里我们只是讨论了理论下的情况。 感谢您的阅读。若您存在任何疑问，或觉得我们有些地方存在纰漏，欢迎您联系我们，我们十分乐意与您探讨。 再次感谢两位同学@thorn,@opethrax深夜的探讨与陪伴，若没有他们的帮助，我们很难单独进行下去。 thorn有关这篇文章的链接：https://www.cnblogs.com/thornblog/p/12381381.html opethrax有关这篇文章的链接：https://home.cnblogs.com/u/opethrax/ 他们两位有关这个内容的博客写的都非常优秀，建议您去访问他们的博客以进行更多的了解。 除非另有说明，本网站上的内容均采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，请您在转载时注明来源及博客链接。 4.深夜随想造物主强大的力量是人们无法想象到的。人类很难走到没有任何疑惑的那一天。 每一个个体脑中冒出的新奇想法，或提出的一个问题，都有可能成为筑起人类从无知到有知的桥梁下的一粒石子。 对科学的探索，不是浅尝辄止，而是无穷无尽。 献上一首不错的音乐： “生于此处却不知此处 日光倾城，万物生长，又是为何 若没有大地的拥抱，我们早已消失于茫茫宇宙之中 若没有原子之稳定，我们亦不复存在 无人问天地变换，斗转星移，是为何故 宇宙又是源于何处 它是否无始无终 时间若愿意倒流，我们的认知是否还会有局限 世间最渺小之物又是什么 滚滚长江，却只留有过去，不知未来 浩淼宇宙，为何我们在此相遇” ——《Moonlight》","link":"/2020/02/29/%E6%B5%85%E8%B0%88%E9%AB%98%E4%B8%AD%E7%94%9F%E7%89%A9%E2%80%9D%E7%A2%B1%E5%9F%BA%E5%AF%B9%E7%A1%AE%E5%AE%9A%EF%BC%8C%E6%B1%82DNA%E6%9C%80%E5%A4%9A%E7%A7%8D%E6%95%B0%E2%80%9D%E9%97%AE%E9%A2%98/"},{"title":"浅谈Cauchy不等式","text":"形式$$\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2 \\geq \\sum_{i=1}^{n}a_i^{2}b_i^2$$ 等号成立的条件：$$iff:b_i=0 || \\exists k \\in \\mathbb {R},a_i=k \\cdot b_i(i \\in \\mathbb{N^+})$$ 证明法一：参数配方思路：巧妙的把常数与方程结合起来，利用性质即可。 证明：构造函数:$$f(t)=\\sum_{i=1}^{n}b_i^2\\cdot t^2-2\\sum_{i=1}^{n}a_ib_it+\\sum_{i=1}^{n}a_i^2$$化简函数：$$f(t)=\\sum_{i=1}^{n}b_i^2\\cdot t^2-2\\sum_{i=1}^{n}a_ib_it+\\sum_{i=1}^{n}a_i^2$$ $$=\\sum_{i=1}^{n}(b_i^2t^2-2a_ib_it+a_i^2)$$ $$=\\sum_{i=1}^{n}(b_i^2t^2+a_i^2-2a_ib_it)$$ $$=\\sum_{i=1}^{n}(b_it-a_i)^2$$ 所以：$$f(t) \\geq 0$$ $$\\Delta t=b^2-4ac$$ $$=4\\sum_{i=1}^{n}a_i^2b_i^2-4\\times \\sum_{i=1}^{n}b_i^2 \\times \\sum_{i=1}^{n}a_i^2 \\leq 0$$ 所以：$$4\\sum_{i=1}^{n}a_i^2b_i^2 \\leq 4\\times \\sum_{i=1}^{n}b_i^2 \\times \\sum_{i=1}^{n}a_i^2$$ $$\\sum_{i=1}^{n}a_i^2 \\times \\sum_{i=1}^{n}b_i^2 \\geq \\sum_{i=1}^{n}a_i^2b_i^2$$ 证毕。 因为：$$f(t)=\\sum_{i=1}^{n}(b_it-a_i)^2$$令$f(t)=0$，即$$a_i=b_it$$此时：$$f(t)_{min}=0​$$即：$$\\Delta t \\leq 0$$故等号可取的一个充分条件即为：$$\\exists k \\in \\mathbb {R},a_i=k \\cdot b_i(i \\in \\mathbb{N^+}）$$ 法二：均值不等式证明思路：运用分析法将原式子化简，使用绝对值三角不等式与均值不等式进行证明。 引用到的均值不等式（证明略）：$$ab \\leq \\frac{a^2+b^2}{2}$$适用条件：$$a,b \\in \\mathbb {R^+}$$等号成立条件：$$iff:a=b$$ 证明：要证：$$\\sum_{i=1}^{n}a_i^2\\sum_{i=1}^{n}b_i^2 \\geq \\sum_{i=1}^{n}a_i^{2}b_i^2$$只需证：$$\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2} \\geq |\\sum_{i=1}^{n}a_ib_i|$$即：$$|\\sum_{i=1}^{n}a_ib_i| \\leq \\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}$$ $$\\frac{|\\sum_{i=1}^{n}a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}}\\leq 1$$ 由绝对值三角不等式：$$|a_1+a_2+a_3+\\cdots+a_n| \\leq |a_1|+|a_2|+|a_3|+ \\cdots + |a_n|$$可得：$$|\\sum_{i=1}^{n}a_ib_i| \\leq \\sum_{i=1}^{n}|a_ib_i|$$所以：$$\\frac{|\\sum_{i=1}^{n}a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}} \\leq \\frac{\\sum_{i=1}^{n}|a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}}$$又因为：$$\\frac{\\sum_{i=1}^{n}|a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}}$$ $$=\\sum_{i=1}^{n}\\frac{|a_i|}{\\sqrt{\\sum_{i=1}^{n}a_i^2}}\\cdot \\frac{|b_i|}{\\sqrt{\\sum_{i=1}^{n}b_i^2}}$$ 由均值不等式：$$ab \\leq \\frac{a^2+b^2}{2}$$可得：$$\\sum_{i=1}^{n}\\frac{|a_i|}{\\sqrt{\\sum_{i=1}^{n}a_i^2}}\\cdot \\frac{|b_i|}{\\sqrt{\\sum_{i=1}^{n}b_i^2}}$$ $$\\leq \\frac{1}{2}\\cdot \\sum_{i=1}^{n}(\\frac{a_i^2}{\\sum_{i=1}^{n}a_i^2}+ \\frac{b_i^2}{\\sum_{i=1}^{n}b_i^2})$$ $$\\leq \\frac{1}{2}\\cdot (\\frac{\\sum_{i=1}^{n}a_i^2}{\\sum_{i=1}^{n}a_i^2}+ \\frac{\\sum_{i=1}^{n}b_i^2}{\\sum_{i=1}^{n}b_i^2})$$ $$\\leq \\frac{1}{2} \\times 2 = 1$$ 即：$$\\frac{|\\sum_{i=1}^{n}a_ib_i|}{\\sqrt {\\sum_{i=1}^{n}a_i^2 \\sum_{i=1}^{n}b_i^2}}\\leq 1$$上述结论成立，证毕。 法三：n维向量证法因为：$$|\\vec a \\cdot \\vec b| = |\\vec a|\\cdot |\\vec b| \\cdot cos \\theta$$所以：$$|\\vec a \\cdot \\vec b| \\leq |\\vec a|\\cdot |\\vec b|$$ $$|\\vec a \\cdot \\vec b|^2 \\leq |\\vec a|^2\\cdot |\\vec b|^2$$ $\\vec a,\\vec b$为$n$维向量时，用坐标的形式展开即可证明。 当$\\vec a=k\\vec b$，即$a$，$b$共线时，等号成立。 申明与感谢 内容采用“知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议”进行许可。请您在转载时注明来源及链接。 感谢@thorn的审稿。","link":"/2020/01/17/%E6%B5%85%E8%B0%88Cauchy%E4%B8%8D%E7%AD%89%E5%BC%8F/"},{"title":"终于结束的起点——CSP-S 2019 第二轮游记","text":"Day -3在教练和自己的劝说下，终于还是选择最后几天停课，专心复习，全力以赴。 Day -2上午一直在复习数论知识，中午睡了个午觉，起来后身体就很难受了。 晚上就直接请假回家睡觉。感觉发烧了，一测，39度左右。感觉药丸。 Day -1早上去医院检查，细菌性感染，开了一些奇奇怪怪的药，整个一天都处于头疼炸裂的状态。 一天都没有复习任何知识。周五中午的活动也参加不了了。 病来如山倒。 自认倒霉。在这个紧要关头，居然生了大病。 Day 0起床后感觉身体状态海星。希望今天别太难受了。 中午去了趟机房，拿了点东西，获得了许多人的关心QAQ 互相祝福后，便直接回家了 中午睡完觉后又开始发烧了，抗生素所带来的不良反应也越来越重，怎么办啊版子还没看完QAQ 算了不管了，放平心态，不管结果了。 Day 1昨天晚上在奇怪的梦中醒来两次，又是因为腹泻。 6：50，早上一出门，发现雪下了好厚一层。 深夜的一中，没有灯光，雪地上只有一些人走过的脚印痕迹。 到了校车上，想休息一会，根本睡不着。 感觉自己已经释怀了，没有什么追求了，心中很平静，但还是睡不着。 到了考场，开考5分钟左右才发题。 看到T1，先找了找规律，把可能有联系的东西都写在了纸上，但是越看越乱，最终交了个50分的暴力。 然后感觉T3的题意较T2好理解，于是想去写T3的部分分。 写了好久，发现有一些小细节，最终没调出来，先去写T2吧。 看到T2链的情况挺好写的，快快的写了个35分就去调T3。 最终没调出来。 出考场，基本上许多人都写出来了T1，发现我的想法已经很接近了，但是考场上还是放弃了。 应该没有什么奇迹了吧。 文化课，你好。 Day 2状态还不错。 考试过程还是不说了。 至于结果，还是不尽人意。 自己一个人打了出租车，心中很平静。 “四年OI一场空”，确实，没有什么奖杯奖牌，没有什么纪念品。 但有时候，过程，难道不就是最可贵的吗。 在OI中，我经历了许多，也学习了许多。 知晓了许多学习方法，明白了许多其他人不知道的知识。 在OI中，我失去了许多，也收获了许多。 失去了大量的文化课时光，失去了高一的寒暑假，以及各种节假日。 但收获了许多朋友，一起一同为了某个目标奋斗的知音者。 终于结束的起点终于写下句点终于我们告别终于我们又回到原点一个个 OIer 的竞赛生涯总是从一场 NOIp 开始，大多也在一场 NOIp 中结束，好似一次次轮回在不断上演。如果这次 NOIp 是你的起点，那么祝你的 OI 生涯如同夏花般绚烂。如果这次 NOIp 是你的终点，那么祝你的 OI 回忆宛若繁星般璀璨。 —Luogu P4994 终于结束的起点 结束了，一切都结束了。 开始了，新的征程要开始了。 取得好成绩的各位，在收获了硕果后也不应该沾沾自喜，争取拼搏出更美好的未来。 没有得到理想成绩的后辈，应该总结经验教训，不要气馁，积水至成渊之时，静待蛟龙诞生之日。 祝进省队的同学，在接下来的WC,CTS,APIO,NOI取得优异的成绩。 朋友，无论你从哪条路走来，希望你能忆起自己挥洒过汗水的日子。OI 也好，其他也罢，至少你曾有过热爱的事情。你曾付出的所有心血，都值得被自己永久记得。 无论你现在的处境如何，顺利继续前进或是刚刚历经一次转折，希望你微笑着拥抱现实。请向前看，前方路还长，还有很多很多值得你热爱的事情。也许是延续旧的热爱，也许是如旧般热爱。爱在心里，爱过，也将爱着。 无论你将走在哪条路上，无论你的下一站在何方，请一如既往地全力以赴。路可能分支，拼搏却永远不变。前路也许不同，但一定精彩纷呈。愿你将过往路上的拼搏精神，继续用于前路。如此看来，过往将以这样的方式，伴你左右至永远。岔路口请你带着梦前进，走向值得期待的未来。 过去如是，现在如是，未来——亦如是。 —Capella AFO.文化课你好！","link":"/2019/11/15/%E7%BB%88%E4%BA%8E%E7%BB%93%E6%9D%9F%E7%9A%84%E8%B5%B7%E7%82%B9%E2%80%94%E2%80%94CSP-S-2019-%E7%AC%AC%E4%BA%8C%E8%BD%AE%E6%B8%B8%E8%AE%B0-BeyondLimits/"},{"title":"CSP-S 2019 第一轮 游记","text":"Day -1早上学校有两节英语两节语文，就翘掉了。 在家里把$XJOI$的开放试卷做完了，$68.5$，成绩不算很好。 听说这次参赛的水军都没了，复赛可能会很难进，感觉自己心态还可以。 下午围观了有趣的四川选手名单，被四川的操作震惊，看来我们还是太$naive$了… 还做了$51nod$的试题，题挺难的，写完后心态大崩 Day 0又请了前三节课的假，把初赛篇的基本知识全过了一遍，感觉还不错。 还把$51nod$的题的题解全看了一遍（upd：事实证明这是正确的做法，因为在真正考试中见到了不少原题） 晚上在机房和$lx$一起又把初赛的基础知识全过了一遍，膜拜$lx$的数学能力 还和$misaka$研究了许久的主定理（upd：第二天居然没有考…） 很早就睡了，也没有考前欢乐。 Day 1好冷啊。 早上8：50就到了，科协的人居然还没有布置考场（太咕了，昨天晚上科协的人忙着印卷子居然让我们自己去准备考场相关事宜，贴条子）。 遇见了许久不见的$spinmry$，还有其他原来认识的人。 9：20进考场，惊奇的发现$zyhh$居然就做我左边，座位还是挨着的，但今年是$AB$卷，所以不担心答案。 但最后我们还是被分开了。。。 再一次吐槽科协的奇妙操作： 1.监考老师说：你们要是没有草稿纸，可以向周围人借。 （啥？去年不是还考过选择题说不能带草稿纸吗？） 2.监考老师说：分赛区填新疆。 （啥？那省份填全国吗？） 3.监考老师说：不能提前交卷。 （啥？这又是什么规定？提前阿克的人不能离场吗？（这里指的不是我）） 最后全部打脸。 看到卷子，感觉题量挺大。 看选择题，做起来都不是很难，居然还有原题。 遇见了一些有趣的数学题，便先放下然后去想后面的题去了。 阅读程序，前两道题都是属于看一眼就知道在干嘛的题，但是判断题当时做起来有点懵。 第三题没怎么看懂，自己造了两组数据模拟了一下，成功解决了判断题，最后两道选择题就蒙了起来。 完善程序，第一题比较简单。 第二题耗了我将近$40mins$的时间，一直没看懂，到最后也是。 交完卷子后便去上物理课去了。 中午回到机房，答案出来了，便开始对。 选择错一道，是那道车牌数学题。 阅读程序第一题判断有个错了。 第二题错了一道选择一道判断，是真的坑题。 当我看到算法复杂度时，我就直接选择了$O(nlogn)$，但是完全没有注意到，这并查集居然没有路径压缩（这什么辣鸡啊 还有第四道判断题，当点$x$与$y$所在连通块相同时，那么他们相乘后的结果显然会$\\geq n$。 第三题据说$cin$不能读空子串，就很生草。 完善程序最后一道就对了$3$个。。。 最后估分77分，在机房人里面排中等吧。 晚上和yyy还有jmh点了三个小菜，在水房边吃边聊，聊一些往昔与来者。 总结： 自己的$dp$功底还是不行，对于状压这种东西，还是得多钻研啊。不能知难而退。 平时心态方面也要放好一点啊。 复赛应该能进，剩下的时光，就留给月考和复赛的训练了吧。 乾坤未定，谁都是匹黑马。 各位加油鸭！ （ps：%yyy %jmh","link":"/2019/10/19/CSP-S-2019-%E7%AC%AC%E4%B8%80%E8%BD%AE-%E6%B8%B8%E8%AE%B0/"},{"title":"算法分析与设计 - Lab2 - 排序算法的性能比较","text":"一. 实验目的实现插入排序（Insertion Sort，IS），自顶向下归并排序（Top-down Mergesort，TDM），自底向上归并排序（Bottom-up Mergesort，BUM），随机快速排序（Random Quicksort，RQ），Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）。 二. 实验内容在计算机上针对不同输入规模数据进行实验，对比上述排序算法的时间及空间占用性能。要求对于每次输入运行 10 次，记录每次时间/空间占用，取平均值。 三. 实验过程首先需要明白实验中所需排序算法的基本原理。笔者在相同的实验环境下分别实现了这几种排序，尽量保证了实验结果不受环境所影响。 1. 插入排序（Insertion Sort，IS）该排序每次将一个元素放到序列中的正确位置，做法是与它前面的元素依次比较，直到找到正确的位置。 正确性证明显而易见：由于是从左往右依次处理每个位置的元素的，所以待排元素左边的子序列一定是单调的。 算法的时间复杂度为 $O(n ^ 2)$，但由于其排序利用的性质，插入排序在大量递增的数据面前能有较好的表现。 12345678910void IS() { for (int i = 1; i &lt; n; i++) { int x = a[i], j = i - 1; while (j &gt;= 0 &amp;&amp; a[j] &gt; x) { a[j + 1] = a[j]; j--; } a[j + 1] = x; }} 2. 自顶向下归并排序（Top-down Mergesort，TDM）由于大的序列排序问题可以分解为其子序列的排序子问题（分治法），故可以将目前的 $[l, r]$ 区间划分为 $[l, mid]$ 和 $[mid + 1, r]$，递归处理。递归回溯过后的这两段区间一定是有序的，进而可以合并这两个子区间，来得到排序过后的 $[l, r]$。 合并的方法即每次取这两个子序列中较小的那个数字，依次放到新的序列里。最后还需要把未放完的子序列中的数字集体放入新序列中。这样得到的新序列一定是有序的。 算法的时间复杂度为 $O(n \\log n)$，是一种比较稳定且优秀的排序方法，并且还有一些应用（e.g. 计算某个序列中的逆序对个数）。 1234567891011121314void TDM(int l, int r) { if (l == r) return ; int mid = (l + r) / 2; TDM(l, mid); TDM(mid + 1, r); int i = l, j = mid + 1, k = l; while (i &lt;= mid &amp;&amp; j &lt;= r) { if(a[i] &gt; a[j]) b[k++] = a[j++]; else b[k++] = a[i++]; } while (i &lt;= mid) b[k++] = a[i++]; while (j &lt;= r) b[k++] = a[j++]; for (int k = l; k &lt;= r; k++) a[k] = b[k];} 3. 自底向上归并排序（Bottom-up Mergesort，BUM）与 TDM 不同，我们也可以把小的有序序列们依次合并成大的有序序列，这样也可以实现整体的排序。元素的个数可以采用 $2$ 的整数次幂，这样的子序列的长度也比较平均。 算法的时间复杂度为 $O(n \\log n)$。 12345678910111213141516171819202122void merge(int l, int mid, int r) { int n1 = mid - l + 1, n2 = r - mid; vector&lt;int&gt; b(n1 + 5), c(n2 + 5); for (int i = 1; i &lt;= n1; i++) b[i] = a[l + i - 1]; for (int i = 1; i &lt;= n2; i++) c[i] = a[mid + i]; int i = 1, j = 1, k = l; while (i &lt;= n1 &amp;&amp; j &lt;= n2) { if (b[i] &lt;= c[j]) a[k++] = b[i++]; else a[k++] = c[j++]; } while (i &lt;= n1) a[k++] = b[i++]; while (j &lt;= n2) a[k++] = c[j++];}void BUM() { for (int now = 1; now &lt;= n; now &lt;&lt;= 1) { for (int l = 1; l &lt;= n; l += 2 * now) { int mid = min(l + now - 1, n), r = min(l + 2 * now - 1, n); merge(l, mid, r); } }} 4. 随机快速排序（Random Quicksort，RQ）快速排序与归并排序（Merge Sort）一样，采用了分治的思想，在每次处理区间的时候，选取一个基准值 $pivot = a[x]$，让 $pivot$ 左边所有数字都小于它本身，让 $pivot$ 右边所有数字都大于它本身。然后再去递归基准值左右两边的区间。 不难发现排序的快慢会受到 $pivot$ 选取策略的影响。随机的去选择 $pivot$ 可以让排序的效率不被输入数据的顺序、大小的特点而明显影响到。 算法的时间复杂度为 $O(n \\log n)$。 123456789101112131415void RQ(int l, int r) { if(l &gt;= r) return ; int i = l, j = r, pivot = a[l + rand() % (r - l + 1)]; while(i &lt;= j) { while(a[i] &lt; pivot) i++; while(a[j] &gt; pivot) j--; if(i &lt;= j) { swap(a[i], a[j]); i++; j--; } } RQ(l, j); RQ(i, r);} 5. Dijkstra 3-路划分快速排序（Quicksort with Dijkstra 3-way Partition，QD3P）QD3P 也使用了基准数 $pivot$ 的概念，将数组分成三个部分：小于 $pivot$ 的部分、等于 $pivot$ 的部分和大于 $pivot$ 的部分。然后递归地对这三个部分分别进行排序，以完成整个排序过程。在处理包含大量重复元素的数据时会展现出优秀的性能。 算法的时间复杂度为 $O(n \\log n)$。 123456789101112131415161718void QD3P(int l, int r) { if (l &gt;= r) return ; int lt = l, gt = r, i = l + 1, pivot = a[l]; while (i &lt;= gt) { if (a[i] &lt; pivot) { swap(a[lt], a[i]); lt++; i++; } else if (a[i] &gt; pivot) { swap(a[i], a[gt]); gt--; } else i++; } QD3P(l, lt - 1); QD3P(gt + 1, r);} 测量时间与空间占用量笔者在此次实验中采用了线上评测系统来更方便的去测试不同排序程序在不同规模数据下的性能表现。即先在本地通过数据生成器，将不同规模、不同特点的数据打包上传至评测系统的服务器，再将各个排序的程序分别提交，查看运行时候的时间、空间占用量。 本次线上评测系统选择的是洛谷平台，洛谷平台为用户提供了「创建题目」以及「提交测评」的功能。 评测结果界面： 以下是用于此次评测的题目的相关信息： 本地的数据生成器（generator.cpp）代码： 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int a[20050];void solve1() { for (int i = 1; i &lt;= n; i++) cout &lt;&lt; rand() % 50 &lt;&lt; (i == n ? &quot;\\n&quot; : &quot; &quot;);}// generate random datavoid solve2() { int m = 0; for (int i = 1; i &lt;= n; i++) { int x = rand() % 100; a[++m] = x; } sort(a + 1, a + m + 1); for (int i = 1; i &lt;= m; i++) cout &lt;&lt; a[i] &lt;&lt; (i == m ? &quot;\\n&quot; : &quot; &quot;);} //generate data which has been sortedint main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); srand(time(0)); // for random data freopen(&quot;sort.in&quot;, &quot;w&quot;, stdout); // write the generated data in the file int n = 20000, type; // set the number of data cout &lt;&lt; n &lt;&lt; endl; cin &gt;&gt; type; type ? solve1() : solve2(); // choose different kinds of data return 0;} 本地的排序过后（sort.cpp）的数据生成器： 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int n, a[20050];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(&quot;sort0.in&quot;, &quot;r&quot;, stdin); freopen(&quot;sort0.out&quot;, &quot;w&quot;, stdout); // generate the right answer after sorting cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort (a + 1, a + n + 1); for (int i = 1; i &lt;= n; i++) cout &lt;&lt; a[i] &lt;&lt; (i == n ? &quot;\\n&quot; : &quot; &quot;); return 0;} 运用线上评测的优势是方便查看时间、空间的占用量，并且能够检测程序的正确性。缺点是显示精度取决于评测提供方，结果可能不够精确。 四. 结果分析1. 大量有序数据（N = 20000）时间占用（单位：$\\mu s$）： 空间占用（单位：$kb$）： 2. 大量重复数据（N = 20000）时间占用（单位：$\\mu s$）： 空间占用（单位：$kb$）： 3. 大量随机数据（N = 20000）时间占用（单位：$\\mu s$）： 空间占用（单位：$kb$）： 4. 少量随机数据（N = 1000）时间占用（单位：$\\mu s$）： 空间占用（单位：$kb$）： 五. 问题回答 Which sort worked best on data in constant or increasing order (i.e., already sorted data)? Why do you think this sort worked best? (1). Insertion Sort. In the first test, Insertion Sort solves the problem the fastest. (2). This is because when the sequence is already sorted, everytime we want to arrange this element to its right position, we can add it to the final sequence directly. Its time complexity turns to $O(n)$. Did the same sort do well on the case of mostly sorted data? Why or why not? (1). For Insertion Sort, it runs much more faster than it runs on the random situation. The reason why has been explained in last question. (2). For QD3P, it runs much more slower than it runs on the mostly repeated situation. In general, did the ordering of the incoming data affect the performance of the sorting algorithms? Please answer this question by referencing specific data from your table to support your answer. (1). Yes. (2). For QD3P, when the data is generated randomly, the cost of time is much more shorter than it runs on sorted data. Which sort did best on the shorter (i.e., n = 1,000) data sets? Did the same one do better on the longer (i.e., n = 100,000) data sets? Why or why not? Please use specific data from your table to support your answer. (1). When $n$ is not very large (e.g. n = 1000), different algorithms takes almost same time to sort. (2). When $n$ is very large, which algorithm works best depends on whether the data is already sorted and the number of repeated number in the data set. Theoretically speaking, QD3P works best in most condition, especially when there are many repeated elements in the data set. But there are also some speical cases. In general, which sort did better? Give a hypothesis as to why the difference in performance exists. (1). QD3P works best in most condition. (2). The performance depends on many aspects, including the size of data, whether the sequence is already sorted, and whether it will use the space of system stack and so on. Are there results in your table that seem to be inconsistent? (e.g., If I get run times for a sort that look like this {1.3, 1.5, 1.6, 7.0, 1.2, 1.6, 1.4, 1.8, 2.0, 1.5} the 7.0 entry is not consistent with the rest). Why do you think this happened? (1). I think it is related to the data and system environment.","link":"/2023/10/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab2-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"title":"算法分析与设计 - Lab1 - 渗透问题","text":"一．实验目的使用并查集(union-find)数据结构，编写程序通过蒙特卡罗模拟(Monte Carlo simulation)来估计渗透阈值。 二．实验内容给定由随机分布的绝缘材料和金属材料构成的组合系统:金属材料占多大比例才能使组合系统成为电导体? 给定一个表面有水的多孔景观(或下面有油)，水将在什么条件下能够通过底部排出(或油渗透到表面)? 科学家已经定义了一个称为渗透(percolation)的抽象过程来模拟这种现象。 我们使用 $N \\times N$ 网格点来模型化一个渗透系统。 每个格点或是 open 格点或是 blocked 格点。 一个 full site 是一个 open 格点，它可以通过一系列的邻近(左、右、上、下) open 格点连通到顶行的一个 open 格点。如果在底行中有一个 full site 格点，则称系统是渗透的。(对于绝缘/金属材料的例子，open 格点对应于金属材料，渗透系统有一条从顶行到底行的金属材料路径，且 full sites 格点导电。对于多孔物质示例，open 格点对应于空格，水可能流过，从而渗透系统使水充满 open 格点，自顶向下流动。) 在一个著名的科学问题中，研究人员对以下问题感兴趣:如果将格点以概率 $p$ 独立地设置为 open 格点(因此以概率 $1-p$ 被设置为 blocked 格点)，系统渗透的概率是多少? 当 $p = 0$ 时，系统不会渗出; 当 $p = 1$ 时，系统渗透。下图显示了 $20 \\times 20$ 随机网格（左）和 $100 \\times 100$ 随机网格（右）的格点空置概率 $p$ 与渗滤概率。 当 $N$ 足够大时，存在阈值 $p*$，使得当 $p &lt; p \\ast$ ，随机 $N \\times N$ 网格几乎不会渗透，并且当 $p &gt; p \\ast$ 时，随机 $N \\times N$ 网格几乎总是渗透。尚未得出用于确定渗滤阈值 $p \\ast$ 的数学解。你的任务是编写一个计算机程序来估计 $p \\ast$。 蒙特卡洛模拟(Monte Carlo simulation). 要估计渗透阈值，考虑以下计算实验: 初始化所有格点为 blocked。 重复以下操作直到系统渗出:2.1. 在所有 blocked 的格点之间随机均匀选择一个格点 $(i, j)$。2.2. 设置这个格点 $(i, j)$ 为 open 格点。 open 格点的比例提供了系统渗透时渗透阈值的一个估计。例如，如果在 $20 \\times 20$ 的网格中，根据以下快照的 open 格点数，那么对渗滤阈值的估计是 $\\frac{204}{400} = 0.51$， 因为当第 $204$ 个格点被 open 时系统渗透。 通过重复该计算实验 $T$ 次并对结果求平均值，我们获得了更准确的渗滤阈值估计。 令是第 $x_t$ 次计算实验中 open 格点所占比例。样本均值提供渗滤阈值的一个估计值; 样本标准差测量阈值的灵敏性。 $$\\mu = \\frac{\\sum_{i = 1}^{T}x_i}{T}, \\quad \\sigma^2 = \\frac{\\sum_{i = 1}^{T}(x_i - \\mu) ^ 2}{T - 1}$$ 假设 $T$ 足够大，以下为渗滤阈值提供 $95%$ 置信区间: $$[\\mu - \\frac{1.96 \\sigma}{\\sqrt{T}}, \\mu + \\frac{1.96 \\sigma}{\\sqrt{T}}]$$ 三．实验过程并查集根据题意，在实验中，可以把首行中的 $n$ 个点由一个特殊点（编号为 $0$）来代替。即在并查集的初始化过程中，把第一行的 $n$ 个点都指向 $0$ 号点。最后一行也同理。 如何给 $N \\times N$ 个点编号？可以采用“先行后列，同时新的一行的第一个点保留”的方法来排号。“保留”的目的是我们需要把第一行、最后一行（第 $N$ 行）的所有点都分别指向对应的特殊点。采用这种方法，可以很方便的通过某个点的行号 $i$ 和列号 $j$ ，推导出其在这种方式下的真正编号。不难得出，$(i, j)$ 的真正编号为 $(i - 1) \\cdot (N + 1) + j$。第一行的点全被指向 $0$ 号点，第 $N$ 行的所有点全被指向 $N ^ 2 - 1$ 号点，其余所有点最开始都指向自己。 同时本人在并查集中采用了路径压缩、按秩合并的技巧，减少了算法的时间复杂度。 该部分的源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738int get_id(int i, int j) { return 1 + (i - 1) * (N + 1) + (j - 1); }struct union_find_set { int fa[MAXN * MAXN], rk[MAXN * MAXN]; int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); } // path compression bool connected(int x, int y) { return find(x) == find(y); } void initial() { for (int i = 1; i &lt;= N; i++) { for (int j = 1; j &lt;= N; j++) { int id = get_id(i, j); fa[id] = id; rk[id] = 1; if (i == 1 || i == N) fa[id] -= j; } } fa[top_id] = top_id; fa[bottom_id] = bottom_id; rk[top_id] = rk[bottom_id] = 2; } void unite(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) return ; if (rk[fx] &lt; rk[fy]) fa[fx] = fy; else { fa[fy] = fx; if (rk[fx] == rk[fy]) rk[fx]++; } } // weighted quick-union}s1; 注意到实验中还需要分析不带按秩合并的并查集在运行相同规模数据时候的表现，只需要在上述代码中的 initial 和 unite 部分中去除与 rk 有关的代码即可（ unite 中直接合并）。在这里不再赘述。 Percolations 与 PercolationStats 类结合题意，本人用 struct 创建了对应的数据类型及接口。 Percolations 部分的源代码： 1234567891011121314151617181920212223242526struct Percolations { struct node { int id, sta; }a[MAXN][MAXN]; bool isOpen(int i, int j) { return a[i][j].sta; } // is site (row i, column j) open? void open(int i, int j) { a[i][j].sta = 1; } // open site (row i, column j) if it is not already bool percolates() { return s1.connected(top_id, bottom_id); } // does the system percolate? void Percolation(int N) { for (int i = 1; i &lt;= N; i++) { for (int j = 1; j &lt;= N; j++) { a[i][j].sta = 0; a[i][j].id = get_id(i, j); } } } // create N-by-N grid, with all sites blocked}now; PercolationStats 部分的源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct PercolationStats { const int dirx[5] = {0, 0, 0, 1, -1}; const int diry[5] = {0, 1, -1, 0, 0}; double res, ave, sigma, sigma_squ; std::vector&lt;double&gt; esti_p; bool check_out(int i, int j) { return i &lt; 1 || j &lt; 1 || i &gt; N || j &gt; N; } // check whether (i, j) is out of the grid double mean() { return res / T; } // sample mean of percolation threshold double variance() { double val = 0; for (auto x : esti_p) val += pow((x - ave), 2); return val / (T - 1); } // sample variance of percolation threshold double stddev() { return sqrt(sigma_squ); } // sample standard deviation of percolation threshold double confidenceLo() { return ave - (1.96 * sigma) / sqrt(T); } // returns lower bound of the 95% confidence interval double confidenceHi() { return ave + (1.96 * sigma) / sqrt(T); } // returns upper bound of the 95% confidence interval void PercolationStat(int N, int T) { for (int k = 1; k &lt;= T; k++) { now.Percolation(N); s1.initial(); int cnt = 0; while (!now.percolates()) { int nx = rand() % N + 1, ny = rand() % N + 1; if (!now.isOpen(nx, ny)) { cnt++; now.open(nx, ny); } for (int i = 1; i &lt;= 4; i++) { int dx = nx + dirx[i], dy = ny + diry[i]; if (check_out(dx, dy)) continue; if (now.isOpen(dx, dy)) { int idu = get_id(dx, dy), idv = get_id(nx, ny); s1.unite(idu, idv); } } } double nowp = 1.0 * cnt / (N * N); esti_p.push_back(nowp); res += nowp; } } // perform T independent computational experiments on an N-by-N void Calculation() { ave = mean(); sigma_squ = variance(); sigma = stddev(); std::cout &lt;&lt; &quot;mean = &quot; &lt;&lt; ave &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;stddev = &quot; &lt;&lt; sigma &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; &quot;95% confidence interval is [&quot; &lt;&lt; confidenceLo() &lt;&lt; &quot;, &quot; &lt;&lt; confi denceHi() &lt;&lt; &quot;]&quot; &lt;&lt; &quot;\\n&quot;; } // calculate the mean, stddev, and the confidence interval of this experiment}lab; 四. 结果分析quick-find 运行表现N = 200, T = 100: N = 2, T = 100000: N = 300, T = 500: weighted quick-find 运行表现N = 200, T = 100: N = 2, T = 100000: N = 300, T = 500: 不难发现在较大规模数据的时候，按秩合并优化对程序时间的减少效果是明显的。","link":"/2023/10/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-Lab1-%E6%B8%97%E9%80%8F%E9%97%AE%E9%A2%98/"},{"title":"计算机组织与体系结构课程设计 - 实验报告","text":"一. 实验目的 深入理解基本模型计算机的功能、组成知识。 深入学习计算机各类典型指令的执行流程。 学习微程序控制器的设计过程和相关技术，掌握 LPM_ROM 的配置方法。 自己设计 5～8 条机器指令，并编写相应的微程序，上机调试，掌握计算机整机概念。掌握微程序的设计方法，学会编写二进制微指令代码表，全面了解并掌握微程序控制方式计算机的设计方法。 二. 实验原理实验中，计算机数据通路的控制将由微过程控制器来完成，CPU 从内存中取出一条机器指令到指令执行结束的一个指令周期，全部由微指令组成的序列来完成，即一条机器指令对应一个微程序。 为了向 RAM 中装入程序和数据，检查写入是否正确，并能启动程序执行，还必须设计三个控制台操作微程序。 存储器读操作（KRD）：下载实验程序后按总清除按键（CLR）后，控制台 SWA、SWB 为 “0 0” 时，可对 RAM 连续手动读操作。 存储器写操作（KWE）：下载实验程序后按总清除按键（CLR）后，控制台 SWA、SWB 为 “0 1” 时，可对 RAM 连续手动写操作。 启动程序（RP）：下载实验程序后按总清除按键（CLR）后，控制台 SWA、SWB 为 “1 1” 时，即可转入到微地址 “01” 号 “取指令” 微指令，启动程序运行。 设计指令说明 其中 IN 为单字长（8 位二进制），其余为双字长指令，XX H 为 addr 对应的十六进制地址码。 当全部微程序设计完毕后，应将每条微指令代码化，设计出二进制微代码表（前提是去弄懂每一位的含义）。笔者在设计的时候为了方便查看，在下表中将每个在相同模块里的微指令用相同的颜色进行了标识。 微程序流程图 三. 实验步骤（1）微程序的输入根据设计出来的二进制微代码表，将微指令按顺序放入 LPM_ROM 配置文件 ROM_5.mif 里。 （2）编辑RAM中的内容 （3）指令功能的验证 编译工程文件，将 .sof 文件上传至实验箱内。 按 1 次系统复位键 8 ，并置键 8 为高电平，使 CPU 允许正常工作。 控制开关（键 4 、键 3 ）设置为 SWB,SWA = 1,1 ，处于程序执行方式。 通过键 2 、键 1 输入运算数据，如 34H ，按 4 次单步键 7，产生 2 个脉冲，执行 2 条微指令，微程序流程进入到控制台的 RP(11) ，此时的微指令地址是 23，微指令码 MC = 008001，IN = 34H。 再用键 7 产生 1 个脉冲，执行 1 条微指令，微程序流程进入到 运行微程序 的最上块： 此时 PC = 00 送地址寄存器 AR = 00 ， PC 自动加 1 ，PC = 01， MC = 01ED82，IN = 34H。 键 7 产生 1 个脉冲，执行微指令 MC = 00C048，RAM 中的第一条指令码 00 进入 BUS，再由 BUS 进入指令寄存器 IR = 00。键 7 再进 1 个脉冲，进入 MC = 001001，执行指令 IN，送数 IN -&gt; R0 = 34H。 键 7 产生 1 个脉冲，执行完 IN 指令后，返回到初始端，执行微指令 MC = 01ED82。 键 7 产生 2 个脉冲后，执行微指令 MC = 01ED83，即执行 SUB 指令的第 1 步：PC 送 AR = 02 ，PC + 1 = 03 ，这时 RAM 中在 02 地址的 0AH 进入 BUS = 0A。 键 7 产生 1 个脉冲，执行微指令 MC = 00E004 ，即执行 SUB 指令的第 2 步： BUS 数据送 AR = 0A，由于 0A 是 SUB 指令的加数的间接地址，而在地址 0A 中放有 01H，最后完成的减法是 34H - 01H = 33H。 键 7 产生 1 个脉冲，MC = 00B005 ，执行 SUB 的第 3 步：将 RAM 中 0A 地址的数据 01H 送 BUS ，再送 DR2 = 01H。注意，此时指令寄存器 IR 中仍放有 SUB 的操作码 10H， PC = 03 指向下一条指令 AND。 键 7 产生 1 个脉冲，MC = 01A206，执行 SUB 的第 4 步（微地址是 05）， R0 送 DR1 = 34H。 键 7 产生 1 个脉冲，MC = 619A01 ，执行 SUB 的最后一步，DR1 - DR2 = 33H，通过总线 BUS 送 R0 = 33H。 键 7 再产生 1 个脉冲，返回到初始端，执行微指令 MC = 01ED82。 键 7 产生 2 个脉冲，MC = 01ED95，执行 AND 指令；键 7 再 4 个脉冲后，位运算与的结果 33H &amp; 12H = 10H 被写入 R0 ，即 R0 = 10H 。键 7 产生 1 个脉冲后返回到初始端，执行微指令 MC = 01ED82。 键 7 产生 2 个脉冲，MC = 01ED99，执行 MOV 指令；键 7 再 2 个脉冲后， RAM 中地址为 0C 的数字 00H 被写入 DR2，即 DR2 = 00H 。键 7 产生 1 个脉冲后返回到初始端，执行微指令 MC = 01ED82。 键 7 产生 2 个脉冲，MC = 01A21B，执行 INC 指令；键 7 再 1 个脉冲后，R0 中的值加 1，即 R0 = 11H 。键 7 产生 1 个脉冲后返回到初始端，执行微指令 MC = 01ED82。 附：实验过程中的图片 四. 实验感想由于「计算机组织与体系结构」是上学期的课程，时隔将近 4 个月后再接触到相关的知识，有一种熟悉又陌生的感觉，当时学到的一些知识已经有所遗忘。所以笔者在设计指令之前，又对 CPU 、数据通路、总线等相关知识进行了回顾与复习。在这次漫长的设计实验以后，我对这方面的知识理解得以更加深刻。 设计指令并构造 24 位微代码是十分辛苦的，在设计第一条指令时花费了很长时间。随着自己对每一位的含义的越来越熟悉，同时也发现了不同指令在某些地方的相似之处，我明白了老师课前所提到的“开头设计指令很慢，之后会越来越快”的含义：有些指令有许多部分是很相似的，在代码上的不同很少，主要是会因为执行下一条指令的位置不同而不同。 同时当时自己为了设计方便，构建微代码表时基本把相同的指令用到的微操作都放在了一起，不断向微地址大的地方累加，这也造成了本人微代码表中会有空行的出现（详见下图），这也是我在实验中意识到自己不足的一个地方。 总的来说这次实验虽然辛苦，但是我收获颇丰。当理论与实际结合起来，并通过自己的努力验证了理论的正确性的时候，心中的激动和成就感是很足的。 最后感谢老师在实验中耐心的答疑与同伴在我出现问题时的“拔刀相助”。","link":"/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"title":"杜文亮深度实践笔记 - chap12 - 数据包嗅探和伪造","text":"课程前置计算机网络知识回顾 $$\\quad$$ Classful Addressing 将 IP 地址分为 5 类。由于网络地址长度是固定的，故每一类 IP 地址可分配的数量也是固定的。这样在分配给企业时有可能造成 IP 地址过多浪费等问题。 Classless Addressing 中网络地址的长度可以自定义（即IP 地址 / 后的数字），引申出子网掩码（Net Mask）的概念。 随着互联网设备的增多，IPV4 已经不能满足为所有设备提供唯一的 IP 地址。IPV6 可以暂时地解决 IP 地址不足的问题，但 NAT（Network Address Translation）可以完美地解决这个问题。大部分电脑都配置有 NAT 服务，该服务允许设备在本地使用自定义的私人 IP 地址，当要与互联网通信时，NAT 会将私人 IP 转译为其在互联网上的真实 IP。 获取 IP 地址的方法有手动和自动。自动获取 IP 地址需借助 DHCP（Dynamic Host Configuration Protocol） 。 DNS（Domain Name System）将 IP 地址与主机名进行对应，方便人们记忆。 12.1 Introduction数据包嗅探和伪造（Packet Sniffing and Spoofing）是两种常见的攻击形式，也是众多其他网络攻击的基础。嗅探（Sniffing）：Trying to receive everybody’s packets.伪造（Spoffing）：Put some fake information into the packet and send it out. 12.2 Use Socket to send packets将数据打包成数据包是很复杂的事情，这件事由 OS 来完成。应用只需要使用 OS 提供的系统调用，将数据通过对应的 API 传入内核即可。 Packets 中不止要包括传输的信息，还需包括使用的协议、目的 IP 地址等信息。 以下是分别使用 Python 和 C++ 编写的 UDP 程序，来进行 Packets Sending 的过程。 12.3 Receiving Packets1. IP layer and above IP layer：判断“我”是否是该数据包要被传送到的最终地址。 Transport layer：IP layer 会判断该数据包所采取的 Transport Protocol（e.g. UDP, TCP），并送至对应的模块。 Application：应用通过端口 port 来接受数据包，因此可以通过 OS 与指定的端口号进行绑定。所以每当数据包到来时，传输层得以知道这是哪个应用需要的数据包。传输层会将数据包存储至对应端口的缓冲区 buffer。 2. IP layer and below &amp; Packet Sniffing一般情况下，当电脑通过网卡 NIC 接收到数据包时，会检测目的地址是否与自己的 MAC 地址相同来判断“这个数据包是不是发给我的”。如果不同则大多数情况下会选择丢弃该数据包。 OS 提供了一种特殊模式来支持 Packet Sniffing（即使不是发给自己的也不选择丢弃，这样才可以“偷”到别人的数据包），该模式叫做混杂模式（Promiscuous Mode）。在混杂模式下，一台机器的网卡能够接收所有经过它的数据流，而不论其目的地址是否是它。 由于 Sniffer Program 位于上层，在 Protocol stack 中的 IP layer 仍会对该数据包的 IP 地址进行检查。也就是说不是发给自己的数据包会在 IP layer 的时候会被检测到异常，从而被丢弃。可以通过一种特殊的 Socket（Raw Socket）来避免这个问题。若存在 Raw Socket，所有数据包会被进行复制并传给这个 Raw Socket。 有时我们只需要对我们有用的数据包，如和 DNS 有关的数据包。所以对嗅探到的数据包进行筛选是很重要的。 BPF 是一种高效的、提前筛选的方法。 12.4 Packet Sniffing","link":"/2023/11/30/%E6%9D%9C%E6%96%87%E4%BA%AE%E6%B7%B1%E5%BA%A6%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0-chap12-%E6%95%B0%E6%8D%AE%E5%8C%85%E5%97%85%E6%8E%A2%E5%92%8C%E4%BC%AA%E9%80%A0/"},{"title":"杜文亮深度实践笔记 - chap4 - 缓冲区溢出攻击","text":"4.1 程序的内存布局程序运行时需要在内存中存放数据。对于一个 $C$ 语言程序，它的内存由 $5$ 个段组成： 代码段（text segment）：存放程序的可执行代码，这一内存块通常是只读（Read Only）的。 数据段（data segment）：存放由程序员初始化的静态（static）/全局（global）变量。 BSS 段（BSS segment）：存放未初始化的静态/全局变量。$OS$ 会把未初始化的变量初始化为 $0$。 堆（heap）：用于动态内存分配，由 malloc(), free()等函数控制。 栈（stack）：存放函数内定义的局部变量，以及和函数调用有关的数据。 4.2 栈与函数调用4.2.1 栈的内存布局当程序中的函数被调用时，需要在栈中为该函数分配一些空间来存储数据，进而执行该函数。 12345void calc(int a, int b) { int x, y; // local variable x = a + b; y = a - b;} 当 calc() 被调用时，$OS$ 会在栈顶为该函数分配一块内存空间，称作栈帧（stack frame）。栈帧的布局如下： 参数：保存给函数传递的参数。顺序是按照相反的顺序存储的。 返回地址：函数结束后需要返回，返回地址区域存储的是函数调用指令的下一条指令的地址。 前帧指针： 局部变量：存放函数中用到的局部变量。 4.2.2 帧指针在运行函数的时候，肯定会用到函数中的参数和局部变量，所以需要知道他们在内存中的地址。但这些地址在编译的时候是无法确定的，因为编译器无法预测到栈在运行时的状态。所以在 CPU 中引入一个寄存器——帧指针，这个寄存器指向栈帧中的一个固定地址，因此其他参数和局部变量的地址可以通过帧指针加上一个偏移量计算出来。 在 x86 架构中，帧指针寄存器（ebp）总是指向前帧指针的地址。对 32 位体系结构而言，返回地址和帧指针各占 $4$ 个字节，故 $a$ 和 $b$ 的实际地址是 $[ebp] + 8$ 和 $[ebp] + 12$。 之前介绍到的按照相反顺序存储的原因在这里也能得到解释：从偏移度的角度来看顺序不是反的，由于栈是从高端地址向低端地址增长的，若先把参数 $a$ 压入栈中，$a$ 的偏移值将会高于 $b$ 。在阅读汇编代码的时候反而会感到奇怪。 4.3 栈的缓冲区溢出攻击4.3.1 &amp; 4.3.2 数据复制与缓冲区溢出12345678910111213#include &lt;string.h&gt;void foo(char *str) { char buffer[12]; strcpy(buffer, str); // buffer overflow will appear after excuting this.}int main() { char *str = &quot;wo bu xin bie kai zhe zhong wan xiao wo bi 12 chang.&quot;; foo(str); return 0;} 在上面的代码中， foo() 中的局部变量 $buffer$ 拥有 $12$ 字节的内存，foo() 使用 strcpy() 从 $str$ 复制数据到 $buffer$ （直到碰到 \\0 才停止执行）。由于 $str$ 的长度比 $12$ 字节大，$str$ 中未被复制完的数据将会被放到 $buffer[12], buffer[13], \\cdots$。 若 $buffer$ 之上的区域包含一些关键数据，若他们被修改了，则会引发一些未知的错误。 4.3.3 缓冲区溢出漏洞123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;void foo(char *str) { char buffer[100]; strcpy(buffer, str);}int main() { char str[400]; FILE *badfile = fopen(&quot;badfile&quot;, &quot;r&quot;); fread(str, sizeof(char), 300, badfile); foo(str); return 0;} 上述程序将系统磁盘上的文件读入，该文件是用户可以自定义的，故带来了风险。","link":"/2023/11/03/%E6%9D%9C%E6%96%87%E4%BA%AE%E6%B7%B1%E5%BA%A6%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0-chap4-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"},{"title":"UCB - CS161 - Lecture 5","text":"1. Kerckhoff’s PrincipleCryptosystems should remain secure even when the attacker knows all internal details of the system.The key should be the only thing that must be kept secret, and the system should be designed to make it easy to change keys that are leaked (or suspected to be leaked).If your secrets are leaked, it is usually a lot easier to change the key than to replace every instance of the running software. 加解密算法是公开的，加解密密钥是保密的： 维护密钥的保密性更容易。 若密钥暴露，换密钥即可。 面对多对加密通信的需求，使用相同的加密算法和不同的密钥即可。相比于使用不同的加密算法，设计成本和复杂程度及各方面代价都大大降低。 开放密码学设计的优势： 可以使该算法承受公开的钻研和分析，因此可以变得更加强壮。 公开后有更大的可能被正义黑客发现，比被敌人发现要好。 公开设计使标准更容易建立。 系统的安全取决于算法的保密性，对代码的逆向抵抗力很差。密钥不是代码的一部分，不存在这个问题。 2. Symmetric-Key Encryption 密文的长度无需成为加密的信息（从反面的角度来论证这种做法的优势）。 对称加密的大体模式： 安全性的考量： partial information leak（通过加密程序返回的密文试探有关信息） deterministic encryptions（相同明文的密文一旦相同，被破解后能大大加快破解全部密文的速度） 2.1 IND-CPA SecurityIND-CPA：Indistinguishability under Chosen-plaintext Attack（选择明文攻击下的不可区分性）。 2.2 One-Time Pad虽安全性极高，但只能用于一次性加密解密，不符合 IND-CPA。 Both the size of key $K$ and message $M$ is $n$，$K = k_1k_2 \\cdots k_n$（randomly chosen）, $C = Enc(K, M) = K \\oplus M$，$Dec(K, C) = K \\oplus C = K \\oplus K \\oplus M = M$。 2.3 Block CiphersIntuitively, a block cipher transforms a fixed-length, $n$-bit input into a fixed-length $n$-bit output. The block cipher has $2 ^ k$ different settings for scrambling, so it also takes in a $k$-bit key as input to determine which scrambling setting should be used. Encryption function $E：{0, 1} ^ k \\times { 0, 1} ^ n \\rightarrow { 0, 1} ^ n$，This notation means we are mapping a $k$-bit input (the key) and an $n$-bit input (the plaintext message) to an $n$-bit output (the ciphertext). Once we fix the key $K$, we get a function mapping $n$ bits to $n$ bits：$E_k : { 0, 1} ^ n \\rightarrow { 0, 1} ^ n$. The inverse mapping of this permutation is the decryption algorithm $D_k$：$D_k(E_k(M)) = M$. 2.3.1 ECB Mode 2.3.2 CBC Mode 2.3.3 CFB Mode","link":"/2024/02/27/UCB-CS161-Lecture-5/"},{"title":"MIT 18.06 - Lecture 3","text":"多角度理解矩阵乘法（Matrix Multiplication）Assume matrix $C$ is the result of matrix $A$ times matrix $B$ , in other words $C = AB$. 行乘列 $c_{ij}$ equals the dot product of row $i$ of matrix $A$ and column $j$ of matrix $B$. In other words： $$ c_{ij} = \\sum_{k = 1} ^ {n} a_{ik} \\cdot b_{kj} $$ It can be directly calculated in $O(n ^ 3)$. 行变换（A 是变换矩阵） The rows of $C$ are combinations of rows of $B$. 列变换（B 是变换矩阵） The columns of $C$ are combinations of columns of $A$. 列乘行 The product of an $m \\times 1$ vector with a $1 \\times p$ vector is a $m \\times p$ matrix. $$ \\left[\\begin{array}{c} 2 \\ 3 \\ 4 \\end{array}\\right] \\left[\\begin{array}{c} 1 \\quad 6 \\end{array}\\right] = \\left[\\begin{array}{c} 2 \\quad 12 \\ 3 \\quad 18 \\ 4 \\quad 24 \\end{array}\\right] $$ The columns of this matrix are multiples of the column of $A$. The rows of this matrix are multiples of the row of $B$. 分块矩阵的乘法 $$ \\left[\\begin{array}{c} A_1 &amp; A_2 \\ A_3 &amp; A_4 \\end{array}\\right] \\left[\\begin{array}{c} B_1 &amp; B_2 \\ B_3 &amp; B_4 \\end{array}\\right] = \\left[\\begin{array}{c} C_1 &amp; C_2 \\ C_3 &amp; C_4 \\end{array}\\right] $$ $A_i$ , $B_j$ and $C_k$ are matrixs, $A_i$ are blocks of a bigger matrix and $B_j$ are blocks with the same cutting methods like $A_i$. What amazing is that it still fits the rules of matrix multiplication！ In other words, $C_1 = A_1B_1 + A_2B_3.$ 矩阵的逆（Inverses）如何理解矩阵的逆？For understand the inverse matrix easily, we need to use the Elimination Matrix which we have metioned in the lecture 2. Assume a elimination matrix $E_{21} = \\left[\\begin{array}{c}1 &amp; 0 &amp; 0 \\-3 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1\\end{array}\\right]$, the second row of $E_{21}$ means subtracting $3$ times row $1$ from row $2$. To “undo” this operation we must add $3$ times row $1$ to row $2$ using the inverse matrix: $$E_{21} ^ {-1} = \\left[\\begin{array}{c}1 &amp; 0 &amp; 0 \\3 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1\\end{array}\\right]$$ It is obviously that $E_{21}^{-1}E_{21} = E_{21}E_{21}^{-1} = \\left[\\begin{array}{c}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1\\end{array}\\right] = I$. 可逆矩阵/非奇异矩阵的定义If $A$ is a square matrix, the most important question you can ask about it is whether it has an inverse $A^{−1}$. If it does, then $A^{−1}A = I = AA^{−1}$ and we say that $A$ is invertible or nonsingular. For a singular matrix $A$ , which means $A$ doesn’t have its corresponding inverse matrix $A^{-1}$, it can be proved that we can always find some non-zero vector $x$ which $Ax = 0$. This conclusion can be proved by using reduction to absurdity. Assume $A$ has its inverse matrix $A^{-1}$, then $Ax = 0$ is equivalent to $A^{-1}Ax = A^{-1} \\cdot 0$, which means $x = 0$. But the precondition is that $x$ is an non-zero vector. Thus contradiction occurs so that singular matrices don’t have their inverse matrices. 求逆矩阵的方法 — Gauss-Jordan EliminationWe combine the method of Guass Elimination with block matrices to get the Gauss-Jordan Elimination. The main idea is: $$E[ \\ A \\ | \\ I \\ ] = [ \\ I \\ | \\ E \\ ]$$ $E$ is the product of all of the elimination matrices during the process of transforming $A$ to $I$ using Guass Elimination.The correctness of this method is obviously due to $EA = I$. According to the defination of inverse martix, $E = A^{-1}$.","link":"/2024/02/17/MIT-18-06-Lecture-3/"},{"title":"MIT 18.06 - Lecture 4","text":"A = LU 分解 $L$ 矩阵是一个下三角矩阵，$U$ 矩阵是一个上三角矩阵。这种表示方式相对于 $EA = U$ 而言更加合适。 $$\\quad$$ 高斯消元的时间复杂度是 $O(n ^ 3)$ 级别的，编程难度不算很大。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;const int N = 150;const double eps = 1e-7;using namespace std;int n;double ans[N], a[N][N];int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); freopen(&quot;in&quot;,&quot;r&quot;, stdin); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n + 1; j++) cin &gt;&gt; a[i][j]; } for (int i = 1; i &lt;= n; i++) { int pos = i; for (int k = i + 1; k &lt;= n; k++) { if (fabs(a[i][i]) &lt; fabs(a[k][i])) pos = k; } if (fabs(a[pos][i]) &lt; eps) { cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; endl; return 0; } if (pos != i) swap(a[i], a[pos]); double div = a[i][i]; for (int j = i; j &lt;= n + 1; j++) a[i][j] /= div; for (int k = i + 1; k &lt;= n; k++) { div = a[k][i]; for (int l = i; l &lt;= n + 1; l++) a[k][l] -= div * a[i][l]; } } ans[n] = a[n][n + 1]; for (int i = n - 1; i &gt;= 1; i--) { ans[i] = a[i][n + 1]; for (int j = i + 1; j &lt;= n; j++) ans[i] -= ans[j] * a[i][j]; } for (int i = 1; i &lt;= n; i++) cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans[i] &lt;&lt; endl; return 0;} 对于消元过程中碰到 pivot 为 0 的情况，需要进行行交换。行交换等价于在原矩阵的左边乘一个置换矩阵（permutation matrix）。因此，$A = LU$ 分解写成 $PA = LU$ 的形式将更完整。 置换矩阵 $P$ 的一个重要性质： $P ^ {-1} = P ^ T$。","link":"/2024/02/26/MIT-18-06-Lecture-4/"},{"title":"MIT 18.06 - Lecture 9","text":"Linear independenceWe say vectors $x_1, x_2, \\cdots x_n$ are linearly independent (or just independent)：if $c_1x_1 + c_2x_2 + \\cdots + c_nx_n = 0$ only when $c_1, c_2, \\cdots , c_n$ are all 0. Thinking of $Ax$ as a linear combination of the column vectors of A, we see that the column vectors of $A$ are independent exactly when the nullspace of $A$ contains only the zero vector.In other words, the only solution to $Ax = 0$ is $x = 0$. If the columns of $A$ are independent then all columns are pivot columns, the rank of $A$ is $n$, and there are no free variables.If the columns of $A$ are dependent then the rank of $A$ is less than $n$ and there are free variables. 包含零向量的向量组，他们之间必定线性相关。 Spanning a spaceVectors $v_1, v_2, \\cdots v_k$ span a space when the space consists of all combinations of those vectors. For example, the column vectors of $A$ span the column space of $A$. Basis and DimensionBasis：A basis for a vector space is a sequence of vectors $v_1, v_2, \\cdots v_d$ with two properties: $v_1, v_2, \\cdots v_d$ are independent. $v_1, v_2, \\cdots v_d$ span the vector space. In general, $n$ vectors in $R_n$ form a basis if they are the column vectors of an invertible matrix. Dimension：Given a space, every basis for that space has the same number of vectors, that number is the dimension of the space.So there are exactly $n$ vectors in every basis for $R_n$.","link":"/2024/03/09/MIT-18-06-Lecture-9/"},{"title":"MIT 18.06 - Lecture 10","text":"Four subspacesAny $m \\times n$ matrix $A$ determines four subspaces (possibly containing only the zero vector): Column space, $C(A)$$C(A)$ consists of all combinations of the columns of $A$ and is a vector space in $R_m$. The $r$ pivot columns form a basis for $C(A)$. $$dim \\ C(A) = r.$$ Nullspace, $N(A)$$N(A)$ consists of all solutions $x$ of the equation $Ax = 0$ and lies in $R_n$. The special solutions to $A_x = 0$ correspond to free variables and form a basis for $N(A)$. An $m \\times n$ matrix has $n − r$ free variables: $$dim \\ N(A) = n - r.$$ Row space, $C(A ^ T)$$C(A ^ T)$ consists of all combinations of the rows of $A$ and is a vector space in $R_n$.We equate this with $C(A ^ T)$, the column space of the transpose of $A$. To get the basis of the row space, one obvious way is to perform row reduction on $A ^ T$, but instead we make use of $R$, the row reduced echelon form of $A$. During the process, it leads to the difference of column space between $A$ and $R$ (after many row changes operations).Although the column spaces of $A$ and $R$ are different, the row space of $R$ is the same as the row space of $A$(row changes don’t influence the row space). The rows of $R$ are combinations of the rows of $A$. The first $r$ rows of $R$ are the ”echelon” basis for the row space of $A$: $$dim \\ C(A ^ T) = r.$$ Left nullspace, $N(A ^ T)$We call the nullspace of $A ^ T$ the left nullspace of A. This is a subspace of $R_m$. The matrix $A ^ T$ has $m$ columns. We just saw that $r$ is the rank of $A ^ T$, so the number of free columns of $A ^ T$ must be $m − r$. $$dim \\ N(A ^ T) = m - r.$$ The left nullspace is the collection of vectors $y$ for which $A ^ T y = 0.$ Equivalently, $y ^ T A = 0$; here $y$ and $0$ are row vectors.","link":"/2024/03/09/MIT-18-06-Lecture-10/"},{"title":"MIT 18.06 - Lecture 7 &amp; 8","text":"Solving Ax = 0 对 $A$ 进行消元。在消元的过程中，可能会遇见该列没有主元的情况，继续寻找下一个主元即可。在消元的过程中，可能会遇见某一行被消为 0 的情况：这说明在 $A$ 中这一行是其他行的线性组合。 有主元的列（pivot columns），没主元的列（free columns）对应的方程组中的变量 $x_2, x_4$ 可以取任意值，也称他们为自由变量。通过自由变量的取值，可以确定主元的取值。 矩阵中主元的个数 $r$ 也被称作该矩阵的秩（rank），自由变量的个数 $m = n - r$。一般每个自由变量轮流取值为 $1$，其余全都取 $0$。由此可以得到 $m$ 个特解。这 $m$ 个特解的线性组合就是 $A$ 对应的零空间。 通过消元，使得 $Ax = 0$ 变成 $Ux = 0$；再将所有 pivots 的值都变成 1，且 pivots 之上和之下都变成 0，实现从 $Ux = 0$ 变成 $Rx = 0$ 的过程。 最终的 $R$ 被称作简化行阶梯形式（reduced row echelon form）的矩阵。 由于 $A$ 对应的零空间是 $A$ 中列向量的线性组合，所以可以将 $A$ 的列进行交换。转化成上图中 $R$ 的形式后，可以借助矩阵乘法，引入一个零空间矩阵 $N$ 使得 $RN = 0$，不难得出 $N$ 的样子。 $N$ 中的每一列就是自由变量不同取值所得到的特解，$N$ 中列向量线性组合的结果就是 $N$ 所对应的零空间。用这种方法可以很快的得到 $Ax = 0$ 的解。 Solving Ax = b“If there is a solution $x$ to $Ax = b$, then $b$ must be a linear combination of the columns of $A$. The system of linear equations $Ax = b$ is solvable exactly when $b$ is a vector in the column space of A.” 满足条件 $Ax = b$ 的所有解：特解 + 零向量空间中的所有向量。 特解：让所有的自由变量取值为 0。 Augmented matrix：增广矩阵 由于 $Ax_p = b , \\ Ax_n = 0 \\Rightarrow (Ax_p + Ax_n = b, \\ A(x_p + x_n) = b)$，故通过这种方式可以得到所有满足条件的解。 上图中的 $x_{complete} = \\cdots$ 中，第二项前少加了 $c_1$。 矩阵的秩与线性方程组的解的关系对于一个 $m \\times n$ 的矩阵 $A$，其秩为 $r$。 行满秩（Full row rank, r = m）最简矩阵形式：$ \\left[\\begin{array}{c} I \\quad F \\end{array}\\right]$没有全是 $0$ 的行，故对 $b$ 无要求（因为消元后不会出现 $0 = b$ 的线性组合 的情况），即 $Ax = b$ 对任何 $b$ 始终有解，且有无穷多解。自由变量的个数 $= n - r = n - m$（零空间的维度是 $n - m$）。 列满秩（Full Column rank, r = n）最简矩阵形式：$ \\left[\\begin{array}{c} I \\ 0 \\end{array}\\right]$ 在这种情况下，零向量空间只包含零向量，也代表着列向量们是线性无关的。 自由变量的个数 $= n - r = n - n = 0$（自由变量的个数相当于是零空间的维度），即若 $Ax = b$ 有解，则必定是唯一解。即在列满秩的情况下，$Ax = b$ 的解的个数是 0 或 1。 行列同时满秩（Full row and column rank, r = m = n）最简矩阵形式：$I$代表着 $A$ 是一个可逆方阵。The nullspace has dimension zero, and $Ax = b$ has a unique solution for every $b$ in $R ^ m$.","link":"/2024/03/01/MIT-18-06-Lecture-7-&-8/"},{"title":"MIT 18.06 - Lecture 5 &amp; 6","text":"置换矩阵（permutation）$$P ^ {-1} = P ^ T \\ P P ^ {-1} = I$$ 转置（transposes）$$(A ^ T){ij} = A{ji}$$ 对称矩阵（symmetric martix）满足 $A ^ T = A$ 的矩阵，称为对称矩阵。构造对称矩阵的通用方法：$\\forall A$（所有矩阵，不是方阵也可以），$A ^ TA$ 一定是一个对称矩阵。（$(A ^ TA) ^ T = A ^ TA$）。 向量空间（vector spaces）If a collection of vectors is closed under linear combinations (i.e. under addition and multiplication by any real numbers), and if multiplication and addition behave in a reasonable way , then we call that collection a vector space. 向量子空间（vector subspaces）A vector space that is contained inside of another vector space is called a subspace of that space. The union $P \\cup L$ of those two subspaces is not a subspace, the intersection $S \\cap T$ of those two subspaces is a subspace. 向量列空间（column spaces） If there is a solution $x$ to $Ax = b$, then $b$ must be a linear combination of the columns of $A$. The system of linear equations $Ax = b$ is solvable exactly when $b$ is a vector in the column space of A. 向量零空间（nullspace） 使得 $Ax = 0$ 的 $x$ 组成了矩阵 $A$ 的向量零空间（为什么是空间的证明很简单，在上面已给出）。但使得 $Ax = b, b \\neq 0$ 的 $x$ 构不成一个空间，因为不包含零向量。","link":"/2024/02/28/MIT-18-06-Lecture-5-&-6/"},{"title":"MIT 18.06 - Lecture 1 &amp; 2","text":"线性方程组的几何化e.g. $$2x - y = 0 \\-x + 2y = 3$$ 行视角（Row Picture）:解集是直线们的交点 或 平面们的交线等。 列视角（Column Picture）:找到已知向量组的线性组合，来表达出目的向量。 矩阵视角（Matrix Picture）:写成 $Ax = b$ 的形式，其中 $A$ 是系数矩阵，$x$ 是未知数向量，$b$ 是结果向量。 线性（不）相关给定矩阵 $A$ ，若对于任意一个向量 $b$ ，都能找到一个向量 $x$ 满足 $Ax = b$，则说明$A$ 中的列向量们的线性组合”可以触碰到所处空间的任何一个角落”（二维平面、三维空间……），称 $A$ 中的列向量们是线性不相关的（linearly independent）。 若不能，则称 $A$ 为奇异矩阵（singular matrix），在这个奇异矩阵中的列向量们是线性相关的（linearly dependent），因此他们的线性组合总是汇集在一个点/一条线/一个平面/…上，因此无法触碰到所处空间的任何一个角落。 高斯消元法 (Guass Elimination)求解线性方程组的解时，若采用矩阵视角，可以写成 $Ax = b$。 e.g. 然后通过消元，求解出未知数向量 $x$ 即可（保证 $A$ 可逆），步骤如下： 找到该行的 pivot ，将下面每行该位置的数变成 0（**We recopy the first row, then multiply the numbers in it by an appropriate value and subtract those values from the numbers in the second row.**）。 若该行的 pivot 为 0 ，可以通过把后续行与该行进行交换，来继续消元。 直到 $A$ 变成一个上三角矩阵 $U$（upper triangular matrix），停止消元。 通过上述步骤，我们把 $Ax = b$ 变成了 $Ux = c$ 的形式，接着通过回代法（back substitution）便可以得到原方程的解。 $$\\quad$$ 刚才 $A$ 变成 $U$ 的过程，可以用矩阵乘法来描述。每次消元的步骤 1，都可以表示成在当前矩阵的左侧乘上了一个消元矩阵（下图左侧的消元矩阵叫做 $E_{21}$，因为我们正在想办法将矩阵中第 2 行第 1 列的数字消去）。 所以上述例子的 $A$ 到 $U$ 的过程，可以描述为 $E_{32}(E_{31}(E_{21}A)) = U$，也可以写成:$$(E_{32}E_{31}E_{21})A = U \\EA = U, \\ E = E_{32}E_{31}E_{21}$$ $$\\quad$$还可以发现一些有趣的性质： 若想对 $A$ 进行行变换，则在 $A$ 左边乘上对应的行变换矩阵。 $$ \\left[\\begin{array}{c} 0 &amp; 1 \\ 1 &amp; 0 \\end{array}\\right] \\left[\\begin{array}{c} a &amp; b \\ c &amp; d \\end{array}\\right] = \\left[\\begin{array}{c} c &amp; d \\ a &amp; b \\end{array}\\right] $$ 若想对 $A$ 进行列变换，则在 $A$ 右边乘上对应的列变换矩阵。 $$ \\left[\\begin{array}{c} a &amp; b \\ c &amp; d \\end{array}\\right] \\left[\\begin{array}{c} 0 &amp; 1 \\ 1 &amp; 0 \\end{array}\\right] = \\left[\\begin{array}{c} b &amp; a \\ d &amp; c \\end{array}\\right] $$ 是矩阵乘法中行变换、列变换的基础。","link":"/2024/02/17/MIT-18-06-Lecture-1-&-2/"}],"tags":[{"name":"密码学","slug":"密码学","link":"/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"抽象代数","slug":"抽象代数","link":"/tags/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"},{"name":"网络安全","slug":"网络安全","link":"/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"加缪手记","slug":"加缪手记","link":"/tags/%E5%8A%A0%E7%BC%AA%E6%89%8B%E8%AE%B0/"},{"name":"摘抄","slug":"摘抄","link":"/tags/%E6%91%98%E6%8A%84/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"生物学","slug":"生物学","link":"/tags/%E7%94%9F%E7%89%A9%E5%AD%A6/"},{"name":"算法实验","slug":"算法实验","link":"/tags/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"计组","slug":"计组","link":"/tags/%E8%AE%A1%E7%BB%84/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"软件安全","slug":"软件安全","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/"},{"name":"线性代数","slug":"线性代数","link":"/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}],"categories":[{"name":"网络安全","slug":"网络安全","link":"/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"专业知识","slug":"专业知识","link":"/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"计算机安全","slug":"计算机安全","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"}],"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}]}